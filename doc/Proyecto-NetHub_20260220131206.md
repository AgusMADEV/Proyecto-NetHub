# Reporte de proyecto

## Estructura del proyecto

```
C:\xampp\htdocs\GitHub\Proyecto-NetHub
â”œâ”€â”€ .env.example
â”œâ”€â”€ .gitignore
â”œâ”€â”€ 001-smtp_envio_correo.py
â”œâ”€â”€ 002-imap_leer_correo.py
â”œâ”€â”€ 003a-socket_servidor.py
â”œâ”€â”€ 003b-socket_cliente.py
â”œâ”€â”€ 004a-websocket_servidor.py
â”œâ”€â”€ 004b-websocket_cliente.py
â”œâ”€â”€ 005-ia_remota_jocarsa.py
â”œâ”€â”€ 006-tame_ia_personalizada.py
â”œâ”€â”€ 007-ia_ollama_python.py
â”œâ”€â”€ 008-api_rest_flask.py
â”œâ”€â”€ 009a-socket_tls_servidor.py
â”œâ”€â”€ 009b-socket_tls_cliente.py
â”œâ”€â”€ README.md
â”œâ”€â”€ dashboard.html
â”œâ”€â”€ database_models.py
â”œâ”€â”€ metrics_prometheus.py
â”œâ”€â”€ nethub.py
â””â”€â”€ requirements.txt
```

## CÃ³digo (intercalado)

# Proyecto-NetHub
**001-smtp_envio_correo.py**
```python
#!/usr/bin/env python3
"""
====================================================
  MÃ“DULO 1 - ENVÃO DE CORREO POR SMTP
====================================================
EnvÃ­a un correo electrÃ³nico HTML con Python usando
smtplib y las credenciales del archivo .env
====================================================
"""

import os
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from dotenv import load_dotenv

# IntegraciÃ³n con base de datos
try:
    from database_models import SessionLocal, crear_log, crear_mensaje
    DB_DISPONIBLE = True
except ImportError:
    DB_DISPONIBLE = False

# Cargar variables de entorno desde el archivo .env
load_dotenv()

SMTP_SERVER   = os.getenv("SMTP_SERVER",   "smtp.example.com")
SMTP_PORT     = int(os.getenv("SMTP_PORT", "587"))
SMTP_USER     = os.getenv("SMTP_USER",     "usuario@example.com")
SMTP_PASSWORD = os.getenv("SMTP_PASSWORD", "contraseÃ±a")


def enviar_correo(destinatario: str, asunto: str, cuerpo_html: str) -> bool:
    """
    EnvÃ­a un correo HTML al destinatario indicado.

    ParÃ¡metros:
        destinatario  -- direcciÃ³n de correo del receptor
        asunto        -- asunto del mensaje
        cuerpo_html   -- contenido HTML del cuerpo

    Retorna True si se enviÃ³ con Ã©xito, False en caso de error.
    """
    msg = MIMEMultipart("alternative")
    msg["Subject"] = asunto
    msg["From"]    = SMTP_USER
    msg["To"]      = destinatario

    # Parte HTML del mensaje
    parte_html = MIMEText(cuerpo_html, "html", "utf-8")
    msg.attach(parte_html)

    try:
        with smtplib.SMTP(SMTP_SERVER, SMTP_PORT) as servidor:
            servidor.ehlo()
            servidor.starttls()
            servidor.login(SMTP_USER, SMTP_PASSWORD)
            servidor.sendmail(SMTP_USER, destinatario, msg.as_string())
        
        print(f"[SMTP] âœ… Correo enviado correctamente a {destinatario}")
        
        # Registrar en base de datos
        if DB_DISPONIBLE:
            db = SessionLocal()
            try:
                crear_log(db, "INFO", "SMTP", f"Email enviado a {destinatario}: {asunto}")
                crear_mensaje(db, "EMAIL", SMTP_USER, destinatario, asunto, cuerpo_html[:100])
            finally:
                db.close()
        
        return True
        
    except smtplib.SMTPException as error:
        print(f"[SMTP] âŒ Error al enviar el correo: {error}")
        
        # Registrar error en base de datos
        if DB_DISPONIBLE:
            db = SessionLocal()
            try:
                crear_log(db, "ERROR", "SMTP", f"Error enviando email a {destinatario}: {str(error)}")
            finally:
                db.close()
        
        return False


def main():
    destinatario = input("Introduce el correo destinatario: ").strip()
    asunto       = "Saludo desde TAME - Python SMTP"

    cuerpo = """
    <!DOCTYPE html>
    <html lang="es">
    <head><meta charset="UTF-8"></head>
    <body style="font-family: Arial, sans-serif; background:#f4f4f4; padding:30px;">
      <div style="max-width:600px; margin:auto; background:#fff; border-radius:8px;
                  padding:30px; box-shadow:0 2px 8px rgba(0,0,0,0.1);">
        <h1 style="color:#2c3e50;">TAME - Sistema de Comunicaciones</h1>
        <p>Hola,</p>
        <p>Este mensaje ha sido enviado automÃ¡ticamente desde una aplicaciÃ³n Python
           como parte de la actividad de <strong>ProgramaciÃ³n de Servicios y Procesos</strong>.</p>
        <hr>
        <p>MÃ³dulos implementados:</p>
        <ul>
          <li>âœ… EnvÃ­o SMTP</li>
          <li>âœ… Lectura IMAP</li>
          <li>âœ… Sockets TCP (cliente/servidor)</li>
          <li>âœ… WebSockets (cliente/servidor)</li>
          <li>âœ… ConexiÃ³n a IA remota</li>
          <li>âœ… IA personalizada TAME (Ollama)</li>
        </ul>
        <p style="color:#999; font-size:12px;">Enviado el 19/02/2026</p>
      </div>
    </body>
    </html>
    """

    enviar_correo(destinatario, asunto, cuerpo)


if __name__ == "__main__":
    main()

```
**002-imap_leer_correo.py**
```python
#!/usr/bin/env python3
"""
====================================================
  MÃ“DULO 2 - LECTURA DE CORREO POR IMAP
====================================================
Conecta a un servidor IMAP, lee los Ãºltimos correos
de la bandeja de entrada y los muestra formateados.
====================================================
"""

import os
import imaplib
import email
from email.header import decode_header
from dotenv import load_dotenv

# IntegraciÃ³n con base de datos
try:
    from database_models import SessionLocal, crear_log
    DB_DISPONIBLE = True
except ImportError:
    DB_DISPONIBLE = False

# Cargar variables de entorno
load_dotenv()

IMAP_SERVER   = os.getenv("IMAP_SERVER",   "imap.example.com")
IMAP_PORT     = int(os.getenv("IMAP_PORT", "993"))
IMAP_USER     = os.getenv("SMTP_USER",     "usuario@example.com")
IMAP_PASSWORD = os.getenv("SMTP_PASSWORD", "contraseÃ±a")
MAX_CORREOS   = 10


def decodificar_cabecera(valor: str) -> str:
    """Decodifica cabeceras MIME (asunto, remitente, etc.)."""
    partes = decode_header(valor)
    resultado = []
    for parte, charset in partes:
        if isinstance(parte, bytes):
            try:
                resultado.append(parte.decode(charset or "utf-8", errors="replace"))
            except LookupError:
                resultado.append(parte.decode("utf-8", errors="replace"))
        else:
            resultado.append(parte)
    return "".join(resultado)


def obtener_cuerpo(mensaje: email.message.Message) -> str:
    """Extrae el texto plano o HTML del cuerpo del correo."""
    cuerpo = ""
    if mensaje.is_multipart():
        for parte in mensaje.walk():
            tipo = parte.get_content_type()
            disposicion = str(parte.get("Content-Disposition", ""))
            if tipo == "text/plain" and "attachment" not in disposicion:
                payload = parte.get_payload(decode=True)
                charset = parte.get_content_charset() or "utf-8"
                cuerpo = payload.decode(charset, errors="replace")
                break
            elif tipo == "text/html" and "attachment" not in disposicion and not cuerpo:
                payload = parte.get_payload(decode=True)
                charset = parte.get_content_charset() or "utf-8"
                cuerpo = "[HTML] " + payload.decode(charset, errors="replace")[:200]
    else:
        payload = mensaje.get_payload(decode=True)
        charset = mensaje.get_content_charset() or "utf-8"
        cuerpo = payload.decode(charset, errors="replace") if payload else ""
    return cuerpo.strip()


def leer_correos() -> list[dict]:
    """
    Se conecta al servidor IMAP y lee los Ãºltimos MAX_CORREOS correos.
    Retorna una lista de diccionarios con los datos de cada correo.
    """
    correos_leidos = []

    try:
        # ConexiÃ³n segura SSL
        conexion = imaplib.IMAP4_SSL(IMAP_SERVER, IMAP_PORT)
        conexion.login(IMAP_USER, IMAP_PASSWORD)
        print(f"[IMAP] âœ… Conectado como {IMAP_USER}")
        
        # Registrar conexiÃ³n exitosa
        if DB_DISPONIBLE:
            db = SessionLocal()
            try:
                crear_log(db, "INFO", "IMAP", f"ConexiÃ³n exitosa a {IMAP_SERVER}")
            finally:
                db.close()

        # Seleccionar la bandeja de entrada
        conexion.select("INBOX")

        # Buscar todos los mensajes
        estado, ids_bytes = conexion.search(None, "ALL")
        if estado != "OK" or not ids_bytes[0]:
            print("[IMAP] ğŸ“­ No hay mensajes en la bandeja.")
            conexion.logout()
            return []

        ids = ids_bytes[0].split()
        # Los mÃ¡s recientes primero (limitamos a MAX_CORREOS)
        ids_recientes = ids[-MAX_CORREOS:][::-1]

        for num_id in ids_recientes:
            estado, datos = conexion.fetch(num_id, "(RFC822)")
            if estado != "OK":
                continue

            msg_raw = datos[0][1]
            mensaje = email.message_from_bytes(msg_raw)

            asunto  = decodificar_cabecera(mensaje.get("Subject", "(Sin asunto)"))
            remite  = decodificar_cabecera(mensaje.get("From", ""))
            fecha   = mensaje.get("Date", "")
            cuerpo  = obtener_cuerpo(mensaje)

            correo_info = {
                "id":      num_id.decode(),
                "asunto":  asunto,
                "de":      remite,
                "fecha":   fecha,
                "cuerpo":  cuerpo[:300],  # Primeros 300 caracteres
            }
            correos_leidos.append(correo_info)

        conexion.logout()
        print(f"[IMAP] ğŸ“¬ Se han leÃ­do {len(correos_leidos)} correos.")
        
        # Registrar lectura exitosa
        if DB_DISPONIBLE:
            db = SessionLocal()
            try:
                crear_log(db, "INFO", "IMAP", f"{len(correos_leidos)} correos leÃ­dos de bandeja de entrada")
            finally:
                db.close()

    except imaplib.IMAP4.error as error:
        print(f"[IMAP] âŒ Error de conexiÃ³n: {error}")
        
        # Registrar error
        if DB_DISPONIBLE:
            db = SessionLocal()
            try:
                crear_log(db, "ERROR", "IMAP", f"Error de conexiÃ³n: {str(error)}")
            finally:
                db.close()

    return correos_leidos


def mostrar_correos(correos: list[dict]) -> None:
    """Imprime los correos en formato legible por consola."""
    separador = "â”€" * 60
    for i, correo in enumerate(correos, start=1):
        print(f"\n{separador}")
        print(f"  NÂº {i:02d}  |  ID: {correo['id']}")
        print(f"  Asunto : {correo['asunto']}")
        print(f"  De     : {correo['de']}")
        print(f"  Fecha  : {correo['fecha']}")
        print(f"  Cuerpo : {correo['cuerpo'][:120]}...")
    print(f"\n{separador}")


def main():
    print("=" * 60)
    print("  LECTOR DE CORREO IMAP - TAME")
    print("=" * 60)
    correos = leer_correos()
    if correos:
        mostrar_correos(correos)
    else:
        print("[IMAP] No se pudo leer ningÃºn correo.")


if __name__ == "__main__":
    main()

```
**003a-socket_servidor.py**
```python
#!/usr/bin/env python3
"""
====================================================
  MÃ“DULO 3A - SERVIDOR TCP (SOCKET)
====================================================
Servidor TCP que acepta mÃºltiples clientes de forma
concurrente usando hilos. Responde a comandos bÃ¡sicos
y tambiÃ©n consulta a Ollama si el cliente lo pide.
====================================================
Uso: python 003a-socket_servidor.py
     (ejecutar antes que el cliente)
====================================================
"""

import socket
import threading
import json
import datetime

# IntegraciÃ³n con base de datos
try:
    from database_models import SessionLocal, crear_log, crear_conexion, cerrar_conexion
    DB_DISPONIBLE = True
except ImportError:
    DB_DISPONIBLE = False

HOST  = "127.0.0.1"
PORT  = 9500
ENCODE = "utf-8"


def procesar_comando(comando: str) -> dict:
    """
    Procesa el comando enviado por el cliente y retorna
    un diccionario con la respuesta.
    """
    cmd = comando.strip().lower()

    if cmd == "hora":
        return {
            "estado": "ok",
            "comando": "hora",
            "respuesta": datetime.datetime.now().strftime("%H:%M:%S")
        }
    elif cmd == "fecha":
        return {
            "estado": "ok",
            "comando": "fecha",
            "respuesta": datetime.datetime.now().strftime("%d/%m/%Y")
        }
    elif cmd == "ping":
        return {
            "estado": "ok",
            "comando": "ping",
            "respuesta": "pong"
        }
    elif cmd == "info":
        return {
            "estado": "ok",
            "comando": "info",
            "respuesta": "Servidor TAME v1.0 - ProgramaciÃ³n de Servicios y Procesos"
        }
    elif cmd == "adios" or cmd == "bye":
        return {
            "estado": "cierre",
            "comando": cmd,
            "respuesta": "Hasta luego. Cerrando conexiÃ³n..."
        }
    else:
        return {
            "estado": "ok",
            "comando": cmd,
            "respuesta": f"Comando '{comando}' no reconocido. Comandos: hora | fecha | ping | info | adios"
        }


def manejar_cliente(conexion: socket.socket, direccion: tuple) -> None:
    """
    Hilo dedicado a un cliente. Recibe comandos en texto
    y responde en JSON hasta que el cliente se desconecta.
    """
    print(f"[SERVIDOR TCP] âœ… Cliente conectado: {direccion[0]}:{direccion[1]}")
    
    # Registrar conexiÃ³n en BD
    conexion_id = None
    if DB_DISPONIBLE:
        db = SessionLocal()
        try:
            crear_log(db, "INFO", "TCP", f"Cliente conectado desde {direccion[0]}:{direccion[1]}")
            result = crear_conexion(db, "TCP", direccion[0], direccion[1], HOST, PORT)
            conexion_id = result['id'] if result else None
        finally:
            db.close()

    # Mensaje de bienvenida
    bienvenida = {
        "estado": "bienvenida",
        "mensaje": "Bienvenido al servidor TAME. Escribe un comando (hora, fecha, ping, info, adios)."
    }
    try:
        conexion.sendall(json.dumps(bienvenida, ensure_ascii=False).encode(ENCODE))

        while True:
            datos = conexion.recv(1024)
            if not datos:
                break                         # El cliente cerrÃ³ la conexiÃ³n

            mensaje = datos.decode(ENCODE).strip()
            print(f"[SERVIDOR TCP] â† [{direccion[0]}] {mensaje}")

            respuesta = procesar_comando(mensaje)
            conexion.sendall(json.dumps(respuesta, ensure_ascii=False).encode(ENCODE))
            print(f"[SERVIDOR TCP] â†’ [{direccion[0]}] {respuesta['respuesta']}")

            if respuesta.get("estado") == "cierre":
                break

    except (ConnectionResetError, BrokenPipeError):
        print(f"[SERVIDOR TCP] âš ï¸  ConexiÃ³n interrumpida con {direccion}")
    finally:
        conexion.close()
        print(f"[SERVIDOR TCP] âŒ Cliente desconectado: {direccion[0]}:{direccion[1]}")
        
        # Cerrar conexiÃ³n en BD
        if DB_DISPONIBLE and conexion_id:
            db = SessionLocal()
            try:
                cerrar_conexion(db, conexion_id)
                crear_log(db, "INFO", "TCP", f"Cliente desconectado {direccion[0]}:{direccion[1]}")
            finally:
                db.close()


def iniciar_servidor() -> None:
    """Inicia el servidor TCP y espera conexiones."""
    servidor = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # Reutilizar puerto al reiniciar
    servidor.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    servidor.bind((HOST, PORT))
    servidor.listen(5)

    print("=" * 50)
    print(f"  SERVIDOR TCP TAME  â€”  {HOST}:{PORT}")
    print("=" * 50)
    print("  Esperando conexiones...\n")

    try:
        while True:
            conexion, direccion = servidor.accept()
            hilo = threading.Thread(
                target=manejar_cliente,
                args=(conexion, direccion),
                daemon=True
            )
            hilo.start()
    except KeyboardInterrupt:
        print("\n[SERVIDOR TCP] ğŸ›‘ Servidor detenido por el usuario.")
    finally:
        servidor.close()


if __name__ == "__main__":
    iniciar_servidor()

```
**003b-socket_cliente.py**
```python
#!/usr/bin/env python3
"""
====================================================
  MÃ“DULO 3B - CLIENTE TCP (SOCKET)
====================================================
Cliente TCP que se conecta al servidor TAME y envÃ­a
comandos interactivos recibiendo respuestas JSON.
====================================================
Uso: python 003b-socket_cliente.py
     (el servidor debe estar en ejecuciÃ³n)
====================================================
"""

import socket
import json

HOST   = "127.0.0.1"
PORT   = 9500
ENCODE = "utf-8"


def recibir_respuesta(sock: socket.socket) -> dict | None:
    """
    Recibe un mensaje JSON del servidor.
    Retorna el diccionario parseado o None si falla.
    """
    try:
        datos = sock.recv(4096)
        if not datos:
            return None
        return json.loads(datos.decode(ENCODE))
    except (json.JSONDecodeError, OSError) as error:
        print(f"[CLIENTE TCP] âš ï¸  Error al recibir: {error}")
        return None


def iniciar_cliente() -> None:
    """Conecta al servidor y gestiona el bucle interactivo."""
    print("=" * 50)
    print(f"  CLIENTE TCP TAME  â€”  {HOST}:{PORT}")
    print("=" * 50)

    try:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as cliente:
            cliente.connect((HOST, PORT))
            print(f"[CLIENTE TCP] âœ… Conectado a {HOST}:{PORT}\n")

            # Recibir bienvenida del servidor
            respuesta = recibir_respuesta(cliente)
            if respuesta:
                print(f"[SERVIDOR] {respuesta.get('mensaje', '')}\n")

            while True:
                try:
                    comando = input("Comando > ").strip()
                except EOFError:
                    break

                if not comando:
                    continue

                # Enviar comando al servidor
                cliente.sendall(comando.encode(ENCODE))

                # Recibir respuesta
                respuesta = recibir_respuesta(cliente)
                if respuesta is None:
                    print("[CLIENTE TCP] ğŸ”Œ ConexiÃ³n cerrada por el servidor.")
                    break

                estado   = respuesta.get("estado", "")
                mensaje  = respuesta.get("respuesta", "")
                print(f"[SERVIDOR] [{estado.upper()}] {mensaje}")

                if estado == "cierre":
                    break

    except ConnectionRefusedError:
        print(f"[CLIENTE TCP] âŒ No se pudo conectar a {HOST}:{PORT}")
        print("              AsegÃºrate de que el servidor estÃ© en ejecuciÃ³n.")
    except KeyboardInterrupt:
        print("\n[CLIENTE TCP] ğŸ›‘ Cliente detenido.")


if __name__ == "__main__":
    iniciar_cliente()

```
**004a-websocket_servidor.py**
```python
#!/usr/bin/env python3
"""
====================================================
  MÃ“DULO 4A - SERVIDOR WEBSOCKET
====================================================
Servidor WebSocket asÃ­ncrono basado en la librerÃ­a
'websockets'. Acepta mÃºltiples clientes, hace broadcast
de mensajes y responde a comandos especiales.

Requiere: pip install websockets
====================================================
Uso: python 004a-websocket_servidor.py
     (ejecutar antes que el cliente)
====================================================
"""

import asyncio
import json
import datetime
import websockets
from websockets.server import WebSocketServerProtocol

# IntegraciÃ³n con base de datos
try:
    from database_models import SessionLocal, crear_log, crear_conexion, cerrar_conexion
    DB_DISPONIBLE = True
except ImportError:
    DB_DISPONIBLE = False

HOST  = "localhost"
PORT  = 9501

# Conjunto de clientes conectados
clientes: set[WebSocketServerProtocol] = set()


async def broadcast(mensaje: dict, origen: WebSocketServerProtocol | None = None) -> None:
    """
    EnvÃ­a un mensaje JSON a todos los clientes conectados,
    excepto al origen (si se indica).
    """
    if not clientes:
        return
    texto = json.dumps(mensaje, ensure_ascii=False)
    destinatarios = clientes - {origen} if origen else clientes
    await asyncio.gather(
        *[cliente.send(texto) for cliente in destinatarios],
        return_exceptions=True,
    )


async def procesar_mensaje(ws: WebSocketServerProtocol, datos: str) -> dict:
    """
    Procesa el mensaje recibido de un cliente WebSocket.
    Soporta comandos especiales con prefijo '/'.
    """
    datos = datos.strip()

    if datos.startswith("/hora"):
        return {"tipo": "sistema", "respuesta": datetime.datetime.now().strftime("%H:%M:%S")}
    elif datos.startswith("/fecha"):
        return {"tipo": "sistema", "respuesta": datetime.datetime.now().strftime("%d/%m/%Y")}
    elif datos.startswith("/usuarios"):
        return {"tipo": "sistema", "respuesta": f"Usuarios conectados: {len(clientes)}"}
    elif datos.startswith("/ayuda"):
        return {
            "tipo": "sistema",
            "respuesta": "Comandos: /hora | /fecha | /usuarios | /ayuda | o escribe cualquier mensaje (se reenvÃ­a a todos)"
        }
    else:
        # Reenviar a todos los demÃ¡s (chat)
        await broadcast({"tipo": "chat", "mensaje": datos}, origen=ws)
        return {"tipo": "eco", "respuesta": f"Mensaje enviado a todos: {datos}"}


async def gestionar_conexion(ws: WebSocketServerProtocol) -> None:
    """Callback que se ejecuta por cada cliente que se conecta."""
    cliente_id = f"{ws.remote_address[0]}:{ws.remote_address[1]}"
    clientes.add(ws)
    print(f"[WS SERVIDOR] âœ… Conectado: {cliente_id} | Total: {len(clientes)}")
    
    # Registrar conexiÃ³n en BD
    conexion_id = None
    if DB_DISPONIBLE:
        db = SessionLocal()
        try:
            crear_log(db, "INFO", "WebSocket", f"Cliente conectado: {cliente_id}")
            result = crear_conexion(db, "WEBSOCKET", ws.remote_address[0], ws.remote_address[1], HOST, PORT)
            conexion_id = result['id'] if result else None
        finally:
            db.close()

    # Avisar a todos de la nueva conexiÃ³n
    await broadcast({"tipo": "sistema", "respuesta": f"'{cliente_id}' se ha unido."}, origen=ws)

    # Bienvenida al nuevo cliente
    await ws.send(json.dumps({
        "tipo": "bienvenida",
        "respuesta": f"Bienvenido al servidor WebSocket TAME. Eres el cliente {cliente_id}. Escribe /ayuda para ver comandos."
    }, ensure_ascii=False))

    try:
        async for mensaje in ws:
            print(f"[WS SERVIDOR] â† [{cliente_id}] {mensaje}")
            respuesta = await procesar_mensaje(ws, mensaje)
            await ws.send(json.dumps(respuesta, ensure_ascii=False))
            print(f"[WS SERVIDOR] â†’ [{cliente_id}] {respuesta['respuesta']}")

    except websockets.exceptions.ConnectionClosedOK:
        pass
    except websockets.exceptions.ConnectionClosedError as e:
        print(f"[WS SERVIDOR] âš ï¸  ConexiÃ³n cerrada con error: {e}")
    finally:
        clientes.discard(ws)
        await broadcast({"tipo": "sistema", "respuesta": f"'{cliente_id}' se ha desconectado."})
        print(f"[WS SERVIDOR] âŒ Desconectado: {cliente_id} | Total: {len(clientes)}")
        
        # Cerrar conexiÃ³n en BD
        if DB_DISPONIBLE and conexion_id:
            db = SessionLocal()
            try:
                cerrar_conexion(db, conexion_id)
                crear_log(db, "INFO", "WebSocket", f"Cliente desconectado: {cliente_id}")
            finally:
                db.close()


async def main() -> None:
    print("=" * 50)
    print(f"  SERVIDOR WEBSOCKET TAME  â€”  ws://{HOST}:{PORT}")
    print("=" * 50)
    print("  Esperando conexiones...\n")

    async with websockets.serve(gestionar_conexion, HOST, PORT):
        await asyncio.Future()   # Ejecutar indefinidamente


if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print("\n[WS SERVIDOR] ğŸ›‘ Servidor detenido.")

```
**004b-websocket_cliente.py**
```python
#!/usr/bin/env python3
"""
====================================================
  MÃ“DULO 4B - CLIENTE WEBSOCKET
====================================================
Cliente WebSocket asÃ­ncrono que se conecta al servidor
TAME y permite enviar mensajes/comandos en tiempo real.
Usa dos tareas asyncio: una para recibir y otra para
leer la entrada del usuario.

Requiere: pip install websockets
====================================================
Uso: python 004b-websocket_cliente.py
     (el servidor debe estar en ejecuciÃ³n)
====================================================
"""

import asyncio
import json
import sys
import websockets

URI = "ws://localhost:9501"


async def recibir_mensajes(ws) -> None:
    """Tarea que escucha mensajes entrantes del servidor."""
    try:
        async for mensaje_raw in ws:
            try:
                datos = json.loads(mensaje_raw)
                tipo      = datos.get("tipo", "?")
                respuesta = datos.get("respuesta", datos.get("mensaje", ""))
                etiqueta  = {
                    "bienvenida": "ğŸŸ¢ SISTEMA",
                    "sistema":    "âš™ï¸  SISTEMA",
                    "chat":       "ğŸ’¬ CHAT",
                    "eco":        "ğŸ“¤ ECO",
                }.get(tipo, f"[{tipo.upper()}]")
                print(f"\n{etiqueta}: {respuesta}")
                print("Mensaje > ", end="", flush=True)
            except json.JSONDecodeError:
                print(f"\n[RAW] {mensaje_raw}")
    except websockets.exceptions.ConnectionClosed:
        print("\n[CLIENTE WS] ğŸ”Œ Servidor cerrÃ³ la conexiÃ³n.")


async def enviar_mensajes(ws) -> None:
    """Tarea que lee input del usuario y lo envÃ­a al servidor."""
    loop = asyncio.get_event_loop()
    while True:
        try:
            # Leer entrada sin bloquear el event loop
            mensaje = await loop.run_in_executor(None, lambda: input("Mensaje > "))
            mensaje = mensaje.strip()
            if not mensaje:
                continue
            if mensaje.lower() in ("salir", "exit", "quit"):
                print("[CLIENTE WS] ğŸ‘‹ Desconectando...")
                await ws.close()
                break
            await ws.send(mensaje)
        except EOFError:
            break


async def main() -> None:
    print("=" * 50)
    print(f"  CLIENTE WEBSOCKET TAME  â€”  {URI}")
    print("=" * 50)
    print("  Conectando...\n")

    try:
        async with websockets.connect(URI) as ws:
            print(f"[CLIENTE WS] âœ… Conectado a {URI}")
            print("  Escribe tu mensaje o un comando (/ayuda, /hora, /fecha, /usuarios)")
            print("  Escribe 'salir' para desconectar.\n")

            # Ejecutar las dos tareas de forma concurrente
            tarea_recibir = asyncio.create_task(recibir_mensajes(ws))
            tarea_enviar  = asyncio.create_task(enviar_mensajes(ws))

            # Terminar cuando cualquiera de las dos finalice
            done, pending = await asyncio.wait(
                [tarea_recibir, tarea_enviar],
                return_when=asyncio.FIRST_COMPLETED,
            )
            for tarea in pending:
                tarea.cancel()

    except ConnectionRefusedError:
        print(f"[CLIENTE WS] âŒ No se pudo conectar a {URI}")
        print("              AsegÃºrate de que el servidor WebSocket estÃ© en ejecuciÃ³n.")
    except KeyboardInterrupt:
        print("\n[CLIENTE WS] ğŸ›‘ Detenido por el usuario.")


if __name__ == "__main__":
    asyncio.run(main())

```
**005-ia_remota_jocarsa.py**
```python
#!/usr/bin/env python3
"""
====================================================
  MÃ“DULO 5 - CONEXIÃ“N A SERVIDOR DE IA REMOTO
====================================================
Conecta a la API REST del servidor de IA jocarsa
(expuesto a travÃ©s de ngrok) usando requests.
Las credenciales se leen desde el archivo .env

Requiere: pip install requests python-dotenv
====================================================
"""

import os
import json
import requests
from dotenv import load_dotenv

# IntegraciÃ³n con base de datos
try:
    from database_models import SessionLocal, crear_log
    DB_DISPONIBLE = True
except ImportError:
    DB_DISPONIBLE = False

# Deshabilitar avisos de SSL no verificado
import urllib3
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

load_dotenv()

# URL y API Key del servidor remoto de IA jocarsa
IA_REMOTA_URL = os.getenv(
    "IA_REMOTA_URL",
    "https://tu-ngrok-url.ngrok-free.app/api.php"
)
IA_REMOTA_KEY = os.getenv("IA_REMOTA_KEY", "TEST_API_KEY_JOCARSA_123")


def preguntar_ia_remota(pregunta: str) -> str:
    """
    EnvÃ­a una pregunta a la API REST de jocarsa y retorna la respuesta.

    ParÃ¡metros:
        pregunta -- texto de la consulta

    Retorna la respuesta como cadena de texto.
    """
    # Registrar consulta en BD
    if DB_DISPONIBLE:
        db = SessionLocal()
        try:
            crear_log(db, "INFO", "IA_Remota", f"Consulta: {pregunta[:50]}...")
        finally:
            db.close()
    
    try:
        respuesta = requests.post(
            IA_REMOTA_URL,
            headers={"X-API-Key": IA_REMOTA_KEY},
            data={"question": pregunta},
            timeout=120,
            verify=False,   # Certificado auto-firmado de ngrok
        )
    except requests.exceptions.ConnectionError:
        error_msg = "âŒ Error: No se pudo conectar al servidor de IA remoto."
        if DB_DISPONIBLE:
            db = SessionLocal()
            try:
                crear_log(db, "ERROR", "IA_Remota", "Error de conexiÃ³n")
            finally:
                db.close()
        return error_msg
    except requests.exceptions.Timeout:
        error_msg = "âŒ Error: El servidor tardÃ³ demasiado en responder (timeout)."
        if DB_DISPONIBLE:
            db = SessionLocal()
            try:
                crear_log(db, "ERROR", "IA_Remota", "Timeout")
            finally:
                db.close()
        return error_msg
    except requests.exceptions.RequestException as e:
        if DB_DISPONIBLE:
            db = SessionLocal()
            try:
                crear_log(db, "ERROR", "IA_Remota", str(e))
            finally:
                db.close()
        return f"âŒ Error en la solicitud: {e}"

    if respuesta.status_code != 200:
        return f"âŒ El servidor respondiÃ³ con HTTP {respuesta.status_code}: {respuesta.text}"

    try:
        payload = respuesta.json()
    except json.JSONDecodeError:
        return f"âŒ Respuesta no es JSON vÃ¡lido:\n{respuesta.text}"

    respuesta_texto = payload.get("answer")
    if respuesta_texto is None:
        return f"âŒ La respuesta no contiene el campo 'answer'.\nPayload: {payload}"

    return respuesta_texto


def main():
    print("=" * 60)
    print("  CLIENTE IA REMOTA JOCARSA â€” API REST")
    print("=" * 60)
    print(f"  Servidor : {IA_REMOTA_URL}")
    print("  Escribe 'salir' para terminar.\n")

    while True:
        try:
            pregunta = input("TÃº > ").strip()
        except (EOFError, KeyboardInterrupt):
            print("\n[IA REMOTA] ğŸ‘‹ Cerrando.")
            break

        if not pregunta:
            continue
        if pregunta.lower() in ("salir", "exit", "quit"):
            print("[IA REMOTA] ğŸ‘‹ Â¡Hasta pronto!")
            break

        print("[IA REMOTA] â³ Consultando...")
        respuesta = preguntar_ia_remota(pregunta)
        print(f"\n[IA REMOTA] ğŸ¤– {respuesta}\n")


if __name__ == "__main__":
    main()

```
**006-tame_ia_personalizada.py**
```python
#!/usr/bin/env python3
"""
====================================================
  MÃ“DULO 6 - IA PERSONALIZADA TAME (Ollama local)
====================================================
TAME (Tutor AutÃ³nomo de MÃ³dulos de Estudio) es una
IA personalizada que actÃºa como asistente docente
para la asignatura de ProgramaciÃ³n de Servicios y
Procesos de DAM-2.

Usa el modelo local de Ollama con un system prompt
personalizado que define la identidad de TAME.

Requiere: pip install requests
          ollama corriendo en localhost:11434
====================================================
"""

import json
import requests

OLLAMA_URL = "http://localhost:11434/api/chat"
MODELO     = "qwen2.5:7b-instruct-q4_0"   # Modelo por defecto del aula

# Historial de la conversaciÃ³n (memoria de contexto)
HISTORIAL: list[dict] = []

# Personalidad de TAME
SYSTEM_PROMPT = """Eres TAME, el Tutor AutÃ³nomo de MÃ³dulos de Estudio.
Eres un asistente docente especializado en la asignatura de
'ProgramaciÃ³n de Servicios y Procesos' del ciclo DAM-2 (Desarrollo de
Aplicaciones Multiplataforma).

Tu especialidad cubre los siguientes bloques temÃ¡ticos:
1. ProgramaciÃ³n multiproceso (subprocess, multiprocessing, psutil)
2. ProgramaciÃ³n multihilo (threading, concurrent.futures)
3. Comunicaciones en red (sockets TCP/UDP, SMTP, IMAP)
4. GeneraciÃ³n de servicios en red (WebSockets, APIs REST, HTTP)
5. ProgramaciÃ³n segura (gestiÃ³n de errores, cifrado bÃ¡sico, .env)

Responde siempre en espaÃ±ol, de forma clara y pedagÃ³gica. Si el alumno
tiene dudas de cÃ³digo, muestra ejemplos concretos en Python. Cuando
expliques conceptos tÃ©cnicos, usa analogÃ­as sencillas. Eres amable,
paciente y motivador. Si alguien te pregunta quiÃ©n eres, di que eres
TAME y explica brevemente tu funciÃ³n."""


def chat_tame(pregunta: str) -> str:
    """
    EnvÃ­a una pregunta a TAME (Ollama) manteniendo el historial
    de conversaciÃ³n, y retorna la respuesta como texto.
    """
    # AÃ±adir la pregunta del usuario al historial
    HISTORIAL.append({"role": "user", "content": pregunta})

    payload = {
        "model":    MODELO,
        "messages": [{"role": "system", "content": SYSTEM_PROMPT}] + HISTORIAL,
        "stream":   True,
    }

    try:
        respuesta_http = requests.post(
            OLLAMA_URL,
            json=payload,
            timeout=120,
            stream=True,
        )
        respuesta_http.raise_for_status()
    except requests.exceptions.ConnectionError:
        HISTORIAL.pop()   # Deshacer el mensaje no respondido
        return "âŒ No se pudo conectar a Ollama. Â¿EstÃ¡ en ejecuciÃ³n en localhost:11434?"
    except requests.exceptions.RequestException as e:
        HISTORIAL.pop()
        return f"âŒ Error en la solicitud a Ollama: {e}"

    # Acumular la respuesta en streaming
    texto_respuesta = ""
    print("[TAME] ", end="", flush=True)

    for linea in respuesta_http.iter_lines():
        if not linea:
            continue
        try:
            chunk = json.loads(linea.decode("utf-8"))
        except json.JSONDecodeError:
            continue

        delta = chunk.get("message", {}).get("content", "")
        if delta:
            print(delta, end="", flush=True)
            texto_respuesta += delta

        if chunk.get("done", False):
            break

    print()  # Nueva lÃ­nea al terminar el streaming

    # AÃ±adir respuesta del asistente al historial
    HISTORIAL.append({"role": "assistant", "content": texto_respuesta})

    return texto_respuesta


def main():
    print("=" * 60)
    print("  TAME â€” Tutor AutÃ³nomo de MÃ³dulos de Estudio")
    print("  Asignatura: ProgramaciÃ³n de Servicios y Procesos")
    print("  Modelo: " + MODELO)
    print("=" * 60)
    print("  Escribe tu pregunta o 'salir' para terminar.")
    print("  Escribe 'limpiar' para borrar el historial de conversaciÃ³n.\n")

    while True:
        try:
            pregunta = input("Alumno > ").strip()
        except (EOFError, KeyboardInterrupt):
            print("\n[TAME] ğŸ‘‹ Â¡Hasta la prÃ³xima! Sigue practicando.")
            break

        if not pregunta:
            continue
        if pregunta.lower() in ("salir", "exit", "quit"):
            print("[TAME] ğŸ‘‹ Â¡Hasta la prÃ³xima! Recuerda repasar los apuntes. ğŸ˜Š")
            break
        if pregunta.lower() in ("limpiar", "reset", "nueva"):
            HISTORIAL.clear()
            print("[TAME] âœ… Historial borrado. Nueva conversaciÃ³n.\n")
            continue

        chat_tame(pregunta)
        print()


if __name__ == "__main__":
    main()

```
**007-ia_ollama_python.py**
```python
#!/usr/bin/env python3
"""
====================================================
  MÃ“DULO 7 - CONEXIÃ“N A IA CON PYTHON (Ollama API)
====================================================
Demuestra tres formas distintas de conectarse a un
servidor de IA con Python:

  A) Llamada directa a la API REST de Ollama (/api/generate)
     con requests y sin streaming (respuesta Ãºnica).

  B) Llamada a Ollama con streaming lÃ­nea a lÃ­nea,
     acumulando el texto completo.

  C) Uso del paquete oficial 'ollama' de Python.

Requiere: pip install requests ollama
          ollama corriendo en localhost:11434
====================================================
"""

import json
import sys
import requests

# IntegraciÃ³n con base de datos
try:
    from database_models import SessionLocal, crear_log
    DB_DISPONIBLE = True
except ImportError:
    DB_DISPONIBLE = False

OLLAMA_BASE   = "http://localhost:11434"
MODELO        = "qwen2.5:7b-instruct-q4_0"


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# FORMA A: /api/generate  sin streaming
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def generar_sin_streaming(prompt: str) -> str:
    """
    Llama al endpoint /api/generate de Ollama con stream:false.
    Espera a recibir toda la respuesta de una vez.
    """
    # Registrar consulta
    if DB_DISPONIBLE:
        db = SessionLocal()
        try:
            crear_log(db, "INFO", "Ollama", f"Consulta (sin stream): {prompt[:50]}...")
        finally:
            db.close()
    
    url = f"{OLLAMA_BASE}/api/generate"
    payload = {
        "model":  MODELO,
        "prompt": prompt,
        "stream": False,
    }
    try:
        r = requests.post(url, json=payload, timeout=180)
        r.raise_for_status()
        datos = r.json()
        return datos.get("response", "(Sin respuesta)")
    except requests.exceptions.ConnectionError:
        error_msg = "âŒ Ollama no estÃ¡ en ejecuciÃ³n (localhost:11434)."
        if DB_DISPONIBLE:
            db = SessionLocal()
            try:
                crear_log(db, "ERROR", "Ollama", "Servicio no disponible")
            finally:
                db.close()
        return error_msg
    except requests.exceptions.RequestException as e:
        if DB_DISPONIBLE:
            db = SessionLocal()
            try:
                crear_log(db, "ERROR", "Ollama", str(e))
            finally:
                db.close()
        return f"âŒ Error: {e}"


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# FORMA B: /api/generate  CON streaming  manual
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def generar_con_streaming(prompt: str) -> str:
    """
    Llama al endpoint /api/generate de Ollama con stream:true.
    Imprime cada fragmento en tiempo real y retorna el texto completo.
    """
    url = f"{OLLAMA_BASE}/api/generate"
    payload = {
        "model":  MODELO,
        "prompt": prompt,
        "stream": True,
    }
    texto_completo = ""
    try:
        with requests.post(url, json=payload, timeout=180, stream=True) as r:
            r.raise_for_status()
            for linea in r.iter_lines():
                if not linea:
                    continue
                chunk = json.loads(linea.decode("utf-8"))
                fragmento = chunk.get("response", "")
                if fragmento:
                    print(fragmento, end="", flush=True)
                    texto_completo += fragmento
                if chunk.get("done", False):
                    break
        print()
        return texto_completo
    except requests.exceptions.ConnectionError:
        return "\nâŒ Ollama no estÃ¡ en ejecuciÃ³n (localhost:11434)."
    except requests.exceptions.RequestException as e:
        return f"\nâŒ Error: {e}"


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# FORMA C: paquete oficial 'ollama'
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def generar_con_libreria_ollama(prompt: str) -> str:
    """
    Usa el paquete oficial 'ollama' para Python.
    MÃ¡s limpio y moderno que llamar a la API manualmente.
    """
    try:
        import ollama as ollama_pkg
    except ImportError:
        return "âŒ El paquete 'ollama' no estÃ¡ instalado. Ejecuta: pip install ollama"

    try:
        respuesta = ollama_pkg.generate(model=MODELO, prompt=prompt)
        return respuesta["response"]
    except Exception as e:
        return f"âŒ Error con la librerÃ­a ollama: {e}"


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# PROGRAMA PRINCIPAL â€” MenÃº de demostraciÃ³n
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def mostrar_menu() -> None:
    print("\n  Elige el mÃ©todo de conexiÃ³n:")
    print("  [A] /api/generate  sin streaming (respuesta Ãºnica al final)")
    print("  [B] /api/generate  CON streaming  (texto en tiempo real)")
    print("  [C] Paquete oficial 'ollama'")
    print("  [S] Salir")


def main():
    print("=" * 60)
    print("  CONEXIÃ“N A IA CON PYTHON â€” Ollama API")
    print(f"  Servidor: {OLLAMA_BASE}")
    print(f"  Modelo  : {MODELO}")
    print("=" * 60)

    while True:
        mostrar_menu()
        try:
            opcion = input("\nOpciÃ³n > ").strip().upper()
        except (EOFError, KeyboardInterrupt):
            print("\nğŸ‘‹ Saliendo.")
            break

        if opcion == "S":
            print("ğŸ‘‹ Â¡Hasta pronto!")
            break

        if opcion not in ("A", "B", "C"):
            print("âš ï¸  OpciÃ³n no vÃ¡lida.")
            continue

        try:
            prompt = input("Prompt > ").strip()
        except (EOFError, KeyboardInterrupt):
            break

        if not prompt:
            continue

        print("\n" + "â”€" * 60)

        if opcion == "A":
            print("[A] Respuesta sin streaming:\n")
            respuesta = generar_sin_streaming(prompt)
            print(respuesta)

        elif opcion == "B":
            print("[B] Respuesta con streaming:\n")
            generar_con_streaming(prompt)

        elif opcion == "C":
            print("[C] Respuesta con librerÃ­a 'ollama':\n")
            respuesta = generar_con_libreria_ollama(prompt)
            print(respuesta)

        print("â”€" * 60)


if __name__ == "__main__":
    main()

```
**008-api_rest_flask.py**
```python
#!/usr/bin/env python3
"""
====================================================
  MÃ“DULO 8 - API REST UNIFICADA (Flask)
====================================================
API RESTful que expone todos los servicios de NetHub
mediante endpoints HTTP. Incluye autenticaciÃ³n JWT
y mÃ©tricas.
====================================================
"""

from flask import Flask, request, jsonify, send_file
from flask_cors import CORS
from functools import wraps
import jwt
import datetime
import os
from dotenv import load_dotenv

# Importar el modelo de base de datos
from database_models import (
    SessionLocal, DatabaseSession, crear_log, crear_mensaje
)

# Importar sistema de mÃ©tricas
from metrics_prometheus import (
    REQUEST_COUNT, REQUEST_LATENCY, ACTIVE_CONNECTIONS,
    ERRORS_COUNT, track_request, obtener_metricas_dict
)

load_dotenv()

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#  CONFIGURACIÃ“N
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

SECRET_KEY = os.getenv("JWT_SECRET_KEY", "nethub-secret-key-change-in-production")
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 60

app = Flask(__name__)
app.config['SECRET_KEY'] = SECRET_KEY
CORS(app)  # Permitir CORS para el dashboard

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#  UTILIDADES
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def crear_token(username: str) -> str:
    """Genera un token JWT para el usuario."""
    expiracion = datetime.datetime.utcnow() + datetime.timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    payload = {
        "sub": username,
        "exp": expiracion,
        "iat": datetime.datetime.utcnow()
    }
    return jwt.encode(payload, SECRET_KEY, algorithm=ALGORITHM)

def verificar_token_jwt(token: str) -> str:
    """Verifica el token JWT y retorna el username."""
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        username = payload.get("sub")
        if username is None:
            raise ValueError("Token invÃ¡lido")
        return username
    except jwt.ExpiredSignatureError:
        raise ValueError("Token expirado")
    except jwt.JWTError:
        raise ValueError("No se pudo validar el token")

def requiere_autenticacion(f):
    """Decorador para endpoints que requieren autenticaciÃ³n."""
    @wraps(f)
    def decorated(*args, **kwargs):
        auth_header = request.headers.get('Authorization')
        
        if not auth_header:
            return jsonify({"error": "Token no proporcionado"}), 401
        
        try:
            # Formato: "Bearer <token>"
            parts = auth_header.split()
            if len(parts) != 2 or parts[0].lower() != 'bearer':
                return jsonify({"error": "Formato de token invÃ¡lido"}), 401
            
            token = parts[1]
            username = verificar_token_jwt(token)
            request.username = username  # Guardarlo en el request
            
        except ValueError as e:
            return jsonify({"error": str(e)}), 401
        
        return f(*args, **kwargs)
    
    return decorated

def get_db_session():
    """Obtener sesiÃ³n de base de datos."""
    return SessionLocal()

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#  ENDPOINTS - RAÃZ Y DASHBOARD
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

@app.route('/')
def index():
    """PÃ¡gina principal."""
    return jsonify({
        "nombre": "NetHub API",
        "version": "2.0.0",
        "endpoints": {
            "auth": "/api/auth/login",
            "dashboard": "/dashboard",
            "metrics": "/metrics",
            "docs": "API REST unificada para NetHub"
        }
    })

@app.route('/dashboard')
@app.route('/dashboard.html')
def dashboard():
    """Servir el dashboard HTML."""
    ruta_dashboard = os.path.join(os.path.dirname(__file__), 'dashboard.html')
    return send_file(ruta_dashboard)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#  ENDPOINTS - AUTENTICACIÃ“N
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

@app.route('/api/auth/login', methods=['POST'])
def login():
    """
    Autenticar usuario y obtener token JWT.
    
    Body: {"username": "admin", "password": "admin123"}
    """
    data = request.get_json()
    
    if not data or 'username' not in data or 'password' not in data:
        return jsonify({"error": "Faltan credenciales"}), 400
    
    username = data['username']
    password = data['password']
    
    # ValidaciÃ³n bÃ¡sica
    if len(username) < 3 or len(password) < 6:
        return jsonify({"error": "Credenciales invÃ¡lidas"}), 400
    
    db = get_db_session()
    try:
        from database_models import obtener_usuario_por_username, verificar_password, actualizar_ultimo_acceso
        
        # Obtener usuario de la base de datos
        usuario = obtener_usuario_por_username(db, username)
        
        if not usuario:
            crear_log(db, "WARNING", "API", f"Usuario no existe: {username}")
            return jsonify({"error": "Credenciales incorrectas"}), 401
        
        # Verificar si el usuario estÃ¡ activo
        if not usuario['activo']:
            crear_log(db, "WARNING", "API", f"Usuario inactivo: {username}")
            return jsonify({"error": "Usuario inactivo"}), 403
        
        # Verificar contraseÃ±a
        if not verificar_password(password, usuario['password_hash']):
            crear_log(db, "WARNING", "API", f"ContraseÃ±a incorrecta: {username}")
            return jsonify({"error": "Credenciales incorrectas"}), 401
        
        # Actualizar Ãºltimo acceso
        actualizar_ultimo_acceso(db, username)
        
        # Crear token
        token = crear_token(username)
        crear_log(db, "INFO", "API", f"Login exitoso: {username}")
        
        REQUEST_COUNT.inc(endpoint="login", method="POST")
        
        return jsonify({
            "access_token": token,
            "token_type": "bearer",
            "expires_in": ACCESS_TOKEN_EXPIRE_MINUTES * 60
        })
        
    finally:
        db.close()

@app.route('/api/auth/verify', methods=['GET'])
@requiere_autenticacion
def verificar_autenticacion():
    """Verificar si el token es vÃ¡lido."""
    REQUEST_COUNT.inc(endpoint="verify_token", method="GET")
    return jsonify({
        "status": "ok",
        "username": request.username,
        "authenticated": True
    })

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#  ENDPOINTS - CORREO ELECTRÃ“NICO
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

@app.route('/api/email/send', methods=['POST'])
@requiere_autenticacion
def enviar_email():
    """Enviar correo electrÃ³nico vÃ­a SMTP."""
    data = request.get_json()
    
    if not data or 'destinatario' not in data or 'asunto' not in data or 'cuerpo_html' not in data:
        return jsonify({"error": "Faltan campos requeridos"}), 400
    
    db = get_db_session()
    try:
        # Importar mÃ³dulo SMTP dinÃ¡micamente
        import importlib.util
        spec = importlib.util.spec_from_file_location(
            "smtp_module", 
            os.path.join(os.path.dirname(__file__), "001-smtp_envio_correo.py")
        )
        smtp_mod = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(smtp_mod)
        
        # Enviar correo
        exito = smtp_mod.enviar_correo(
            data['destinatario'], 
            data['asunto'], 
            data['cuerpo_html']
        )
        
        if exito:
            crear_log(db, "INFO", "SMTP", f"Correo enviado a {data['destinatario']}")
            crear_mensaje(db, "SMTP", request.username, data['destinatario'], data['asunto'])
            REQUEST_COUNT.inc(endpoint="send_email", method="POST")
            
            return jsonify({
                "status": "ok",
                "mensaje": "Correo enviado correctamente",
                "destinatario": data['destinatario']
            })
        else:
            return jsonify({"error": "Error al enviar correo"}), 500
            
    except Exception as e:
        crear_log(db, "ERROR", "SMTP", f"Error: {str(e)}")
        ERRORS_COUNT.inc(service="smtp", error_type=type(e).__name__)
        return jsonify({"error": str(e)}), 500
    finally:
        db.close()

@app.route('/api/email/inbox', methods=['GET'])
@requiere_autenticacion
def obtener_bandeja():
    """Obtener Ãºltimos correos de la bandeja de entrada (IMAP)."""
    limite = request.args.get('limite', 10, type=int)
    
    db = get_db_session()
    try:
        crear_log(db, "INFO", "IMAP", f"Consulta de bandeja por {request.username}")
        REQUEST_COUNT.inc(endpoint="get_inbox", method="GET")
        
        return jsonify({
            "status": "ok",
            "mensajes": [],
            "total": 0,
            "info": "Implementar integraciÃ³n con mÃ³dulo IMAP"
        })
    except Exception as e:
        crear_log(db, "ERROR", "IMAP", str(e))
        return jsonify({"error": str(e)}), 500
    finally:
        db.close()

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#  ENDPOINTS - INTELIGENCIA ARTIFICIAL
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

@app.route('/api/ia/ollama', methods=['POST'])
@requiere_autenticacion
def consultar_ollama():
    """Consultar modelo de IA local (Ollama)."""
    data = request.get_json()
    
    if not data or 'prompt' not in data:
        return jsonify({"error": "Falta el campo 'prompt'"}), 400
    
    prompt = data['prompt']
    modelo = data.get('modelo', 'llama2')
    temperatura = data.get('temperatura', 0.7)
    
    db = get_db_session()
    try:
        try:
            import ollama
        except ImportError:
            return jsonify({
                "error": "Ollama SDK no instalado. Instala con: pip install ollama"
            }), 503
        
        crear_log(db, "INFO", "Ollama", f"Consulta por {request.username}: {prompt[:50]}...")
        
        response = ollama.chat(
            model=modelo,
            messages=[{"role": "user", "content": prompt}],
            options={"temperature": temperatura}
        )
        
        respuesta = response["message"]["content"]
        
        REQUEST_COUNT.inc(endpoint="ia_ollama", method="POST")
        
        return jsonify({
            "status": "ok",
            "modelo": modelo,
            "prompt": prompt,
            "respuesta": respuesta,
            "temperatura": temperatura
        })
        
    except Exception as e:
        crear_log(db, "ERROR", "Ollama", str(e))
        ERRORS_COUNT.inc(service="ollama", error_type=type(e).__name__)
        return jsonify({"error": str(e)}), 500
    finally:
        db.close()

@app.route('/api/ia/remota', methods=['POST'])
@requiere_autenticacion
def consultar_ia_remota():
    """Consultar IA remota (jocarsa.com)."""
    data = request.get_json()
    
    if not data or 'prompt' not in data:
        return jsonify({"error": "Falta el campo 'prompt'"}), 400
    
    db = get_db_session()
    try:
        import requests as req
        
        crear_log(db, "INFO", "IA_Remota", f"Consulta por {request.username}")
        
        # AquÃ­ irÃ­a la integraciÃ³n con el servicio remoto
        response = req.post(
            "https://jocarsa.com/ia/api",
            json={"prompt": data['prompt']}
        )
        
        REQUEST_COUNT.inc(endpoint="ia_remota", method="POST")
        
        return jsonify({
            "status": "ok",
            "respuesta": response.json()
        })
        
    except Exception as e:
        crear_log(db, "ERROR", "IA_Remota", str(e))
        ERRORS_COUNT.inc(service="ia_remota", error_type=type(e).__name__)
        return jsonify({"error": str(e)}), 500
    finally:
        db.close()

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#  ENDPOINTS - MONITOREO Y LOGS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

@app.route('/api/logs', methods=['GET'])
@requiere_autenticacion
def obtener_logs():
    """Obtener logs del sistema."""
    limite = request.args.get('limite', 50, type=int)
    servicio = request.args.get('servicio', None)
    
    db = get_db_session()
    try:
        from database_models import obtener_ultimos_logs
        
        logs = obtener_ultimos_logs(db, limite=limite, servicio=servicio)
        
        REQUEST_COUNT.inc(endpoint="get_logs", method="GET")
        
        return jsonify([
            {
                "id": log.id,
                "timestamp": log.timestamp.isoformat(),
                "nivel": log.nivel,
                "servicio": log.servicio,
                "mensaje": log.mensaje
            }
            for log in logs
        ])
        
    finally:
        db.close()

@app.route('/api/stats', methods=['GET'])
@requiere_autenticacion
def obtener_estadisticas():
    """Obtener estadÃ­sticas del sistema."""
    db = get_db_session()
    try:
        from database_models import obtener_estadisticas as get_stats, obtener_logs_por_nivel, obtener_logs_por_servicio
        
        # EstadÃ­sticas generales
        stats = get_stats(db)
        
        # Logs agrupados
        logs_por_nivel = obtener_logs_por_nivel(db)
        logs_por_servicio = obtener_logs_por_servicio(db)
        
        REQUEST_COUNT.inc(endpoint="get_stats", method="GET")
        
        return jsonify({
            "total_logs": stats['total_logs'],
            "total_mensajes": stats['total_mensajes'],
            "total_conexiones": stats['total_conexiones'],
            "logs_por_nivel": logs_por_nivel,
            "logs_por_servicio": logs_por_servicio,
            "timestamp": datetime.datetime.now().isoformat()
        })
        
    finally:
        db.close()

@app.route('/api/logs/clear', methods=['DELETE'])
@requiere_autenticacion
def limpiar_logs():
    """Limpiar todos los logs (solo admin)."""
    if request.username != "admin":
        return jsonify({"error": "Acceso denegado"}), 403
    
    db = get_db_session()
    try:
        db.execute("DELETE FROM logs")
        db.commit()
        
        crear_log(db, "INFO", "API", f"Logs limpiados por {request.username}")
        
        REQUEST_COUNT.inc(endpoint="clear_logs", method="DELETE")
        
        return jsonify({
            "status": "ok",
            "mensaje": "Logs limpiados correctamente"
        })
        
    finally:
        db.close()

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#  ENDPOINTS - MÃ‰TRICAS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

@app.route('/metrics')
def metrics():
    """Obtener mÃ©tricas del sistema en formato JSON."""
    metricas = obtener_metricas_dict()
    return jsonify(metricas)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#  EJECUTAR SERVIDOR
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

if __name__ == "__main__":
    print("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—")
    print("â•‘          NetHub - API REST (Flask)               â•‘")
    print("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
    print()
    print("ğŸŒ Servidor: http://localhost:8000")
    print("ğŸ“Š Dashboard: http://localhost:8000/dashboard")
    print("ğŸ“ˆ MÃ©tricas: http://localhost:8000/metrics")
    print()
    print("ğŸ”‘ Usuario de prueba: admin / admin123")
    print()
    
    # Inicializar base de datos
    from database_models import inicializar_base_datos
    inicializar_base_datos()
    
    # Iniciar servidor Flask
    app.run(host="0.0.0.0", port=8000, debug=True)

```
**009a-socket_tls_servidor.py**
```python
#!/usr/bin/env python3
"""
====================================================
  MÃ“DULO 9A - SERVIDOR TCP CON CIFRADO TLS/SSL
====================================================
Servidor TCP seguro con cifrado TLS para comunicaciones
protegidas. Incluye autenticaciÃ³n de clientes y logging
a base de datos.
====================================================
"""

import socket
import ssl
import threading
import json
import datetime
import os
from pathlib import Path

# Importar modelos de BD
from database_models import SessionLocal, crear_log, crear_conexion, cerrar_conexion
from metrics_prometheus import (
    ACTIVE_CONNECTIONS, registrar_mensaje_recibido, 
    registrar_mensaje_enviado, ERRORS_COUNT
)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#  CONFIGURACIÃ“N
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

HOST = "0.0.0.0"
PORT = 9502
ENCODE = "utf-8"

# Rutas de certificados TLS
CERT_DIR = Path(__file__).parent / "certs"
CERT_FILE = CERT_DIR / "server.crt"
KEY_FILE = CERT_DIR / "server.key"

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#  GENERACIÃ“N DE CERTIFICADOS AUTOFIRMADOS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def generar_certificados_ssl():
    """
    Genera certificados SSL autofirmados si no existen.
    En producciÃ³n, usar certificados de una CA confiable.
    """
    if CERT_FILE.exists() and KEY_FILE.exists():
        print("[TLS] âœ… Certificados SSL encontrados")
        return True
    
    print("[TLS] ğŸ“ Generando certificados SSL autofirmados...")
    
    # Crear directorio si no existe
    CERT_DIR.mkdir(exist_ok=True)
    
    # Intentar con pyOpenSSL
    try:
        from OpenSSL import crypto
        
        # Generar clave privada
        key = crypto.PKey()
        key.generate_key(crypto.TYPE_RSA, 2048)
        
        # Generar certificado
        cert = crypto.X509()
        cert.get_subject().C = "ES"
        cert.get_subject().ST = "Madrid"
        cert.get_subject().L = "Madrid"
        cert.get_subject().O = "NetHub"
        cert.get_subject().OU = "DAM-2"
        cert.get_subject().CN = "localhost"
        
        cert.set_serial_number(1000)
        cert.gmtime_adj_notBefore(0)
        cert.gmtime_adj_notAfter(365 * 24 * 60 * 60)  # 1 aÃ±o
        cert.set_issuer(cert.get_subject())
        cert.set_pubkey(key)
        cert.sign(key, 'sha256')
        
        # Guardar certificado
        with open(CERT_FILE, "wb") as f:
            f.write(crypto.dump_certificate(crypto.FILETYPE_PEM, cert))
        
        # Guardar clave privada
        with open(KEY_FILE, "wb") as f:
            f.write(crypto.dump_privatekey(crypto.FILETYPE_PEM, key))
        
        print(f"[TLS] âœ… Certificados generados con pyOpenSSL")
        return True
        
    except ImportError:
        print("[TLS] âš ï¸  pyOpenSSL no instalado. Intentando con OpenSSL CLI...")
        
        # MÃ©todo alternativo usando subprocess y openssl CLI
        import subprocess
        
        comando = [
            "openssl", "req", "-x509", "-newkey", "rsa:2048",
            "-keyout", str(KEY_FILE),
            "-out", str(CERT_FILE),
            "-days", "365", "-nodes",
            "-subj", "/C=ES/ST=Madrid/L=Madrid/O=NetHub/OU=DAM-2/CN=localhost"
        ]
        
        try:
            subprocess.run(comando, check=True, capture_output=True)
            print(f"[TLS] âœ… Certificados generados con OpenSSL CLI")
            return True
        except (subprocess.CalledProcessError, FileNotFoundError):
            print("[TLS] âŒ No se pudieron generar certificados automÃ¡ticamente")
            print("       ")
            print("       Opciones:")
            print("       1. Instala pyOpenSSL: pip install pyOpenSSL")
            print("       2. Instala OpenSSL: https://slproweb.com/products/Win32OpenSSL.html")
            print("       3. Genera manualmente los certificados")
            return False
    
    return True


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#  PROCESAMIENTO DE COMANDOS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def procesar_comando_seguro(comando: str, cliente_info: dict) -> dict:
    """
    Procesa comandos del cliente de forma segura.
    Incluye comandos adicionales para demostrar TLS.
    """
    cmd = comando.strip().lower()
    
    comandos = {
        "hora": lambda: {
            "estado": "ok",
            "comando": "hora",
            "respuesta": datetime.datetime.now().strftime("%H:%M:%S"),
            "cifrado": True
        },
        "fecha": lambda: {
            "estado": "ok",
            "comando": "fecha",
            "respuesta": datetime.datetime.now().strftime("%d/%m/%Y"),
            "cifrado": True
        },
        "ping": lambda: {
            "estado": "ok",
            "comando": "ping",
            "respuesta": "pong",
            "cifrado": True
        },
        "info": lambda: {
            "estado": "ok",
            "comando": "info",
            "servidor": "NetHub TLS Server v2.0",
            "protocolo": f"TLS {cliente_info.get('version', 'unknown')}",
            "cipher": cliente_info.get('cipher', 'unknown'),
            "certificado": "Autofirmado",
            "cifrado": True
        },
        "stats": lambda: {
            "estado": "ok",
            "comando": "stats",
            "conexion_segura": True,
            "ip_cliente": cliente_info.get('ip', 'unknown'),
            "puerto_cliente": cliente_info.get('puerto', 0),
            "cifrado": True
        },
        "help": lambda: {
            "estado": "ok",
            "comando": "help",
            "comandos_disponibles": [
                "hora - Obtener hora actual",
                "fecha - Obtener fecha actual",
                "ping - Test de conectividad",
                "info - InformaciÃ³n del servidor",
                "stats - EstadÃ­sticas de conexiÃ³n",
                "help - Esta ayuda",
                "ia <pregunta> - Consultar IA",
                "exit - Cerrar conexiÃ³n"
            ],
            "cifrado": True
        }
    }
    
    # Comando genÃ©rico
    if cmd in comandos:
        return comandos[cmd]()
    
    # Comando de IA
    if cmd.startswith("ia "):
        pregunta = comando[3:].strip()
        try:
            import ollama
            response = ollama.chat(
                model="llama2",
                messages=[{"role": "user", "content": pregunta}]
            )
            return {
                "estado": "ok",
                "comando": "ia",
                "pregunta": pregunta,
                "respuesta": response["message"]["content"],
                "cifrado": True
            }
        except ImportError:
            return {
                "estado": "error",
                "comando": "ia",
                "mensaje": "Ollama SDK no instalado. Instala con: pip install ollama",
                "cifrado": True
            }
        except Exception as e:
            return {
                "estado": "error",
                "comando": "ia",
                "mensaje": f"Error en IA: {str(e)}",
                "cifrado": True
            }
    
    # Comando desconocido
    return {
        "estado": "error",
        "comando": cmd,
        "mensaje": "Comando no reconocido. Usa 'help' para ver comandos disponibles.",
        "cifrado": True
    }


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#  MANEJADOR DE CLIENTE
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def manejar_cliente_tls(conn_ssl, addr, db):
    """
    Maneja la conexiÃ³n de un cliente TLS.
    """
    cliente_ip, cliente_puerto = addr
    conexion_id = None
    
    try:
        # Obtener informaciÃ³n del cifrado
        cipher = conn_ssl.cipher()
        version = conn_ssl.version()
        
        cliente_info = {
            'ip': cliente_ip,
            'puerto': cliente_puerto,
            'cipher': cipher[0] if cipher else 'unknown',
            'version': version if version else 'unknown'
        }
        
        print(f"\n[TLS] ğŸ”’ Cliente conectado: {cliente_ip}:{cliente_puerto}")
        print(f"      Cipher: {cliente_info['cipher']}")
        print(f"      Version: {cliente_info['version']}")
        
        # Registrar conexiÃ³n en BD
        conexion_id = crear_conexion(
            db,
            tipo="TCP_TLS",
            ip_cliente=cliente_ip,
            puerto_cliente=cliente_puerto,
            ip_servidor=HOST,
            puerto_servidor=PORT,
            estado="ACTIVA"
        ).id
        
        crear_log(
            db,
            "INFO",
            "TCP_TLS",
            f"ConexiÃ³n segura establecida desde {cliente_ip}:{cliente_puerto}",
            ip_origen=cliente_ip
        )
        
        # Mensaje de bienvenida
        bienvenida = {
            "tipo": "bienvenida",
            "mensaje": "Bienvenido al servidor NetHub TLS",
            "version": "2.0",
            "conexion_segura": True,
            "cipher": cliente_info['cipher'],
            "instrucciones": "Escribe 'help' para ver comandos disponibles"
        }
        
        conn_ssl.sendall((json.dumps(bienvenida) + "\n").encode(ENCODE))
        registrar_mensaje_enviado("tcp_tls")
        
        bytes_recibidos = 0
        bytes_enviados = len(json.dumps(bienvenida))
        
        # Loop de comunicaciÃ³n
        while True:
            data = conn_ssl.recv(4096)
            
            if not data:
                print(f"[TLS] ğŸ”Œ Cliente {cliente_ip} desconectado")
                break
            
            bytes_recibidos += len(data)
            mensaje = data.decode(ENCODE).strip()
            
            print(f"[TLS] ğŸ“¨ {cliente_ip}: {mensaje}")
            registrar_mensaje_recibido("tcp_tls")
            
            # Procesar comando
            if mensaje.lower() == "exit":
                respuesta = {
                    "estado": "ok",
                    "mensaje": "Cerrando conexiÃ³n. Â¡Hasta pronto!",
                    "cifrado": True
                }
                conn_ssl.sendall((json.dumps(respuesta) + "\n").encode(ENCODE))
                break
            
            respuesta = procesar_comando_seguro(mensaje, cliente_info)
            respuesta_json = json.dumps(respuesta) + "\n"
            
            conn_ssl.sendall(respuesta_json.encode(ENCODE))
            bytes_enviados += len(respuesta_json)
            registrar_mensaje_enviado("tcp_tls")
            
            print(f"[TLS] ğŸ“¤ Respuesta enviada (cifrada)")
        
        # Cerrar conexiÃ³n en BD
        if conexion_id:
            cerrar_conexion(db, conexion_id, bytes_enviados, bytes_recibidos)
        
        crear_log(
            db,
            "INFO",
            "TCP_TLS",
            f"ConexiÃ³n cerrada: {cliente_ip}:{cliente_puerto} "
            f"({bytes_recibidos} bytes â†“, {bytes_enviados} bytes â†‘)",
            ip_origen=cliente_ip
        )
        
    except ssl.SSLError as e:
        print(f"[TLS] âŒ Error SSL con {cliente_ip}: {e}")
        crear_log(db, "ERROR", "TCP_TLS", f"Error SSL: {str(e)}", ip_origen=cliente_ip)
        ERRORS_COUNT.labels(service="tcp_tls", error_type="ssl_error").inc()
        
    except Exception as e:
        print(f"[TLS] âŒ Error con {cliente_ip}: {e}")
        crear_log(db, "ERROR", "TCP_TLS", f"Error: {str(e)}", ip_origen=cliente_ip)
        ERRORS_COUNT.labels(service="tcp_tls", error_type=type(e).__name__).inc()
        
    finally:
        conn_ssl.close()
        ACTIVE_CONNECTIONS.labels(connection_type="tcp_tls").dec()


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#  SERVIDOR PRINCIPAL
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def iniciar_servidor_tls():
    """Inicia el servidor TCP con TLS."""
    
    # Generar certificados si no existen
    if not generar_certificados_ssl():
        print("[TLS] âŒ No se pudo iniciar el servidor sin certificados")
        return
    
    # Crear contexto SSL
    context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)
    context.load_cert_chain(certfile=CERT_FILE, keyfile=KEY_FILE)
    
    # Configuraciones de seguridad
    context.minimum_version = ssl.TLSVersion.TLSv1_2
    context.set_ciphers('ECDHE+AESGCM:ECDHE+CHACHA20:DHE+AESGCM:DHE+CHACHA20:!aNULL:!MD5:!DSS')
    
    # Crear socket
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    sock.bind((HOST, PORT))
    sock.listen(5)
    
    print("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—")
    print("â•‘       Servidor TCP con Cifrado TLS/SSL          â•‘")
    print("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
    print(f"\nğŸ”’ Servidor escuchando en {HOST}:{PORT}")
    print(f"ğŸ” Cifrado: TLS 1.2+")
    print(f"ğŸ“œ Certificado: {CERT_FILE.name}")
    print(f"ğŸ”‘ Clave: {KEY_FILE.name}")
    print("\nâš¡ Presiona Ctrl+C para detener el servidor")
    print("â”€" * 52)
    
    # Inicializar contador de conexiones
    ACTIVE_CONNECTIONS.labels(connection_type="tcp_tls").set(0)
    
    # Crear log inicial
    db = SessionLocal()
    crear_log(db, "INFO", "TCP_TLS", f"Servidor TLS iniciado en {HOST}:{PORT}")
    db.close()
    
    try:
        while True:
            # Aceptar conexiÃ³n
            conn, addr = sock.accept()
            
            # Envolver en TLS
            conn_ssl = context.wrap_socket(conn, server_side=True)
            
            # Incrementar contador
            ACTIVE_CONNECTIONS.labels(connection_type="tcp_tls").inc()
            
            # Manejar en un hilo separado
            db = SessionLocal()
            hilo = threading.Thread(
                target=manejar_cliente_tls,
                args=(conn_ssl, addr, db),
                daemon=True
            )
            hilo.start()
            
    except KeyboardInterrupt:
        print("\n\n[TLS] ğŸ›‘ Deteniendo servidor...")
        db = SessionLocal()
        crear_log(db, "INFO", "TCP_TLS", "Servidor TLS detenido")
        db.close()
        
    finally:
        sock.close()
        print("[TLS] âœ… Servidor cerrado correctamente")


def main():
    """Punto de entrada principal."""
    iniciar_servidor_tls()


if __name__ == "__main__":
    main()

```
**009b-socket_tls_cliente.py**
```python
#!/usr/bin/env python3
"""
====================================================
  MÃ“DULO 9B - CLIENTE TCP CON CIFRADO TLS/SSL
====================================================
Cliente TCP seguro que se conecta al servidor TLS.
Verifica certificados y establece comunicaciÃ³n cifrada.
====================================================
"""

import socket
import ssl
import json
from pathlib import Path

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#  CONFIGURACIÃ“N
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

HOST = "127.0.0.1"
PORT = 9502
ENCODE = "utf-8"

# Ruta del certificado del servidor (para verificaciÃ³n)
CERT_DIR = Path(__file__).parent / "certs"
CERT_FILE = CERT_DIR / "server.crt"

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#  CLIENTE TLS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def iniciar_cliente_tls():
    """Inicia el cliente TCP con TLS."""
    
    print("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—")
    print("â•‘       Cliente TCP con Cifrado TLS/SSL           â•‘")
    print("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
    print()
    
    # Crear contexto SSL para el cliente
    context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)
    
    # En producciÃ³n, verificar certificados de CA confiables
    # Para certificados autofirmados, desactivamos la verificaciÃ³n
    context.check_hostname = False
    context.verify_mode = ssl.CERT_NONE
    
    # Si queremos verificar el certificado autofirmado:
    # context.load_verify_locations(CERT_FILE)
    # context.verify_mode = ssl.CERT_REQUIRED
    
    # Configurar versiÃ³n mÃ­nima de TLS
    context.minimum_version = ssl.TLSVersion.TLSv1_2
    
    try:
        # Crear socket normal
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        
        # Envolver en TLS
        conn = context.wrap_socket(sock, server_hostname=HOST)
        
        # Conectar al servidor
        print(f"ğŸ”Œ Conectando a {HOST}:{PORT}...")
        conn.connect((HOST, PORT))
        
        # Obtener informaciÃ³n del cifrado
        cipher = conn.cipher()
        version = conn.version()
        
        print(f"âœ… ConexiÃ³n segura establecida")
        print(f"ğŸ” Cipher: {cipher[0] if cipher else 'unknown'}")
        print(f"ğŸ” TLS Version: {version}")
        print()
        
        # Recibir mensaje de bienvenida
        bienvenida = conn.recv(4096).decode(ENCODE)
        if bienvenida:
            try:
                data = json.loads(bienvenida)
                print("ğŸ“¨ Mensaje del servidor:")
                print(f"   {data.get('mensaje', '')}")
                if data.get('conexion_segura'):
                    print(f"   ğŸ”’ ConexiÃ³n cifrada con: {data.get('cipher', 'unknown')}")
                print()
            except json.JSONDecodeError:
                print(f"ğŸ“¨ {bienvenida}")
        
        print("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—")
        print("â•‘  Escribe un comando y presiona ENTER            â•‘")
        print("â•‘  Escribe 'help' para ver comandos disponibles   â•‘")
        print("â•‘  Escribe 'exit' para salir                      â•‘")
        print("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
        print()
        
        # Loop de comunicaciÃ³n
        while True:
            try:
                # Leer comando del usuario
                comando = input("TLS> ").strip()
                
                if not comando:
                    continue
                
                # Enviar comando al servidor (cifrado)
                conn.sendall((comando + "\n").encode(ENCODE))
                
                # Recibir respuesta (cifrada)
                respuesta_raw = conn.recv(4096).decode(ENCODE)
                
                if not respuesta_raw:
                    print("\nâŒ Servidor desconectado")
                    break
                
                # Parsear respuesta JSON
                try:
                    respuesta = json.loads(respuesta_raw)
                    
                    print("\n" + "â”€" * 52)
                    
                    if respuesta.get('estado') == 'ok':
                        print("âœ… Respuesta del servidor:")
                        
                        # Mostrar respuesta segÃºn el comando
                        if 'respuesta' in respuesta:
                            print(f"   {respuesta['respuesta']}")
                        
                        # Comando info
                        if respuesta.get('comando') == 'info':
                            print(f"   Servidor: {respuesta.get('servidor', 'unknown')}")
                            print(f"   Protocolo: {respuesta.get('protocolo', 'unknown')}")
                            print(f"   Cipher: {respuesta.get('cipher', 'unknown')}")
                        
                        # Comando stats
                        if respuesta.get('comando') == 'stats':
                            print(f"   ConexiÃ³n segura: {respuesta.get('conexion_segura', False)}")
                            print(f"   Tu IP: {respuesta.get('ip_cliente', 'unknown')}")
                            print(f"   Tu Puerto: {respuesta.get('puerto_cliente', 'unknown')}")
                        
                        # Comando help
                        if respuesta.get('comando') == 'help':
                            print("   Comandos disponibles:")
                            for cmd in respuesta.get('comandos_disponibles', []):
                                print(f"   â€¢ {cmd}")
                        
                        # Mostrar si estÃ¡ cifrado
                        if respuesta.get('cifrado'):
                            print(f"   ğŸ”’ Cifrado: TLS {version}")
                        
                    else:
                        print("âŒ Error del servidor:")
                        print(f"   {respuesta.get('mensaje', 'Error desconocido')}")
                    
                    print("â”€" * 52 + "\n")
                    
                    # Si el servidor nos dice que va a cerrar
                    if comando.lower() == 'exit':
                        print("ğŸ‘‹ Cerrando conexiÃ³n...")
                        break
                    
                except json.JSONDecodeError:
                    print(f"ğŸ“¨ {respuesta_raw}")
                
            except KeyboardInterrupt:
                print("\n\nâš ï¸  InterrupciÃ³n detectada")
                print("   Cerrando conexiÃ³n...")
                break
            
            except Exception as e:
                print(f"\nâŒ Error: {e}")
                break
        
    except ConnectionRefusedError:
        print("âŒ No se pudo conectar al servidor")
        print("   AsegÃºrate de que el servidor TLS estÃ© ejecutÃ¡ndose")
        print(f"   python 009a-socket_tls_servidor.py")
        
    except ssl.SSLError as e:
        print(f"âŒ Error SSL: {e}")
        print("   Verifica que el servidor tenga certificados vÃ¡lidos")
        
    except Exception as e:
        print(f"âŒ Error inesperado: {e}")
        
    finally:
        try:
            conn.close()
            print("\nâœ… ConexiÃ³n cerrada")
        except:
            pass


def main():
    """Punto de entrada principal."""
    iniciar_cliente_tls()
    
    print("\nğŸ‘‹ Â¡Hasta pronto!")


if __name__ == "__main__":
    main()

```
**README.md**
```markdown
# ğŸŒ NetHub - Sistema Unificado de Comunicaciones en Red

[![Python](https://img.shields.io/badge/Python-3.10+-blue.svg)](https://www.python.org/)
[![Flask](https://img.shields.io/badge/Flask-3.0-green.svg)](https://flask.palletsprojects.com/)
[![License](https://img.shields.io/badge/License-MIT-yellow.svg)]()

**NetHub v2.0** es un sistema completo de comunicaciones en red desarrollado para el mÃ³dulo de **ProgramaciÃ³n de Servicios y Procesos** del ciclo DAM-2. Implementa mÃºltiples protocolos, servicios web, inteligencia artificial y herramientas de monitoreo profesionales.

---

## ğŸ“‹ CaracterÃ­sticas

### ğŸ”§ MÃ³dulos Core
- âœ‰ï¸ **Correo ElectrÃ³nico**: Cliente SMTP con TLS para envÃ­o y cliente IMAP SSL para lectura
- ğŸ”Œ **Sockets TCP**: Servidor y cliente con soporte para mÃºltiples conexiones concurrentes
- ğŸŒ **WebSockets**: ComunicaciÃ³n bidireccional en tiempo real
- ğŸ§  **Inteligencia Artificial**: IntegraciÃ³n con Ollama local y API remota
- ğŸ“ **TAME**: Asistente de enseÃ±anza personalizado con IA

### ğŸš€ Funcionalidades Avanzadas (v2.0)
- ğŸ” **API REST con Flask**: API completa con autenticaciÃ³n JWT
- ğŸ”’ **AutenticaciÃ³n JWT**: Sistema seguro de tokens para autenticaciÃ³n
- ğŸ“Š **Dashboard Web**: Panel de control en tiempo real para monitoreo
- ğŸ—„ï¸ **Base de Datos SQLite**: Persistencia con SQLite3 nativo (sin ORM)
- ğŸ“ˆ **MÃ©tricas Vanilla**: Sistema completo de monitoreo sin dependencias externas
- ğŸ” **Sockets TLS/SSL**: Comunicaciones TCP cifradas con certificados
- ğŸ“Š **MÃ©tricas Nativas**: Sistema de monitoreo vanilla sin dependencias externas

---

## ğŸ› ï¸ InstalaciÃ³n

### Requisitos Previos
- **Python 3.10 o superior**
- pip (gestor de paquetes de Python)

### InstalaciÃ³n de Dependencias

```bash
# Clonar el repositorio
git clone <url-repositorio>
cd Proyecto-NetHub

# Instalar dependencias
pip install -r requirements.txt
```

### ConfiguraciÃ³n del Entorno

1. Copiar el archivo de ejemplo de variables de entorno:
```bash
copy .env.example .env
```

2. Editar `.env` con tus credenciales:
```env
# SMTP (EnvÃ­o de correo)
SMTP_SERVER=smtp.tu-servidor.com
SMTP_PORT=587
SMTP_USER=tu-usuario@ejemplo.com
SMTP_PASSWORD=tu-contraseÃ±a

# IMAP (Lectura de correo)
IMAP_SERVER=imap.tu-servidor.com
IMAP_PORT=993

# IA Remota
IA_REMOTA_URL=https://tu-api.ngrok-free.app/api.php
IA_REMOTA_KEY=tu-clave-api

# JWT (Opcional, se genera automÃ¡ticamente si no existe)
JWT_SECRET_KEY=tu-clave-secreta-muy-segura
```

---

## ğŸš€ Uso

### MenÃº Principal

Ejecutar NetHub con el menÃº interactivo:

```bash
python nethub.py
```

### MÃ³dulos Individuales

TambiÃ©n puedes ejecutar cada mÃ³dulo directamente:

```bash
# Enviar correo
python 001-smtp_envio_correo.py

# Leer correo
python 002-imap_leer_correo.py

# Servidor TCP
python 003a-socket_servidor.py

# Cliente TCP
python 003b-socket_cliente.py

# Servidor WebSocket
python 004a-websocket_servidor.py

# Cliente WebSocket
python 004b-websocket_cliente.py

# IA remota
python 005-ia_remota_jocarsa.py

# TAME IA personalizada
python 006-tame_ia_personalizada.py

# Ollama (3 mÃ©todos)
python 007-ia_ollama_python.py

# API REST
python 008-api_rest_flask.py

# Servidor TLS
python 009a-socket_tls_servidor.py

# Cliente TLS
python 009b-socket_tls_cliente.py
```

---

## ğŸ“Š API REST y Dashboard

### Iniciar API REST

```bash
python 008-api_rest_flask.py
```

### Acceder a la DocumentaciÃ³n

- **Swagger UI**: http://127.0.0.1:8000/api/docs
- **ReDoc**: http://127.0.0.1:8000/api/redoc
- **Dashboard**: http://127.0.0.1:8000/dashboard.html
- **MÃ©tricas (JSON)**: http://127.0.0.1:8000/metrics

### AutenticaciÃ³n

Credenciales por defecto:
- **Usuario**: `admin`
- **ContraseÃ±a**: `admin123`

### Endpoints Principales

```http
POST   /api/auth/login          # AutenticaciÃ³n
GET    /api/auth/verify         # Verificar token
POST   /api/email/send          # Enviar correo
GET    /api/email/inbox         # Leer bandeja
POST   /api/ia/ollama           # Consultar Ollama
POST   /api/ia/remota           # Consultar IA remota
GET    /api/logs                # Obtener logs
GET    /api/stats               # EstadÃ­sticas del sistema
DELETE /api/logs/clear          # Limpiar logs
```

---

## ğŸ” Sockets con TLS/SSL

### Generar Certificados

Los certificados se generan automÃ¡ticamente al iniciar el servidor TLS por primera vez. Se almacenan en la carpeta `certs/`.

Para producciÃ³n, usa certificados de una CA confiable.

### Conectar con Cliente TLS

```bash
# Terminal 1 - Servidor
python 009a-socket_tls_servidor.py

# Terminal 2 - Cliente
python 009b-socket_tls_cliente.py
```

---

## ğŸ—„ï¸ Base de Datos

### Inicializar Base de Datos

```bash
python database_models.py
```

Esto crearÃ¡:
- Base de datos SQLite: `nethub.db`
- Tablas: logs, messages, connections, usuarios, metricas
- Usuario admin por defecto

### Estructura de Tablas

#### Logs
- Registro de eventos del sistema
- Niveles: INFO, WARNING, ERROR, DEBUG
- Servicios: SMTP, IMAP, Socket, API, etc.

#### Messages
- Mensajes enviados/recibidos
- Tipos: EMAIL, SOCKET, WEBSOCKET, API

#### Connections
- Conexiones de red activas/cerradas
- Tipos: TCP, WEBSOCKET, HTTP, TCP_TLS

#### Usuarios
- Usuarios del sistema con autenticaciÃ³n
- Hash de contraseÃ±as con bcrypt

---

## ğŸ“ˆ MÃ©tricas Vanilla y Monitoreo

### CaracterÃ­sticas

- âœ… Sistema nativo sin dependencias externas
- âœ… Formato JSON fÃ¡cil de consumir
- âœ… Thread-safe con locks
- âœ… Bajo overhead de rendimiento
- âœ… Compatible con cualquier sistema de monitoreo

### MÃ©tricas Disponibles

- `nethub_http_requests_total`: Total de peticiones HTTP
- `nethub_request_duration_seconds`: DuraciÃ³n de peticiones
- `nethub_errors_total`: Total de errores
- `nethub_active_connections`: Conexiones activas
- `nethub_messages_sent_total`: Mensajes enviados
- `nethub_messages_received_total`: Mensajes recibidos
- `nethub_auth_attempts_total`: Intentos de autenticaciÃ³n
- `nethub_system_cpu_percent`: Uso de CPU
- `nethub_system_memory_bytes`: Uso de memoria

### Acceso a las MÃ©tricas

Las mÃ©tricas estÃ¡n disponibles en formato JSON en el endpoint `/metrics`:

```bash
curl http://127.0.0.1:8000/metrics
```

**Formato de respuesta:**
```json
{
  "nethub_http_requests_total": {
    "description": "Total de peticiones HTTP recibidas",
    "type": "counter",
    "values": {
      "{\"method\":\"POST\",\"endpoint\":\"login\",\"status\":\"200\"}": 15
    }
  },
  "nethub_active_connections": {
    "description": "NÃºmero de conexiones activas",
    "type": "gauge",
    "values": {
      "{\"connection_type\":\"tcp\"}": 3
    }
  }
}
```

### IntegraciÃ³n con Sistemas de Monitoreo

Las mÃ©tricas en formato JSON pueden integrarse fÃ¡cilmente con:
- Grafana (vÃ­a JSON API datasource)
- ElasticSearch / Kibana
- Custom dashboards
- Scripts de Python/Node.js
- Cualquier sistema que consuma JSON

---

## ğŸ§ª Testing

```bash
# Ejecutar tests
pytest

# Con cobertura
pytest --cov=. --cov-report=html

# Tests especÃ­ficos
pytest tests/test_api.py
```

---

## ğŸ“ Estructura del Proyecto

```
Proyecto-NetHub/
â”‚
â”œâ”€â”€ 001-smtp_envio_correo.py          # EnvÃ­o de correo SMTP
â”œâ”€â”€ 002-imap_leer_correo.py           # Lectura de correo IMAP
â”œâ”€â”€ 003a-socket_servidor.py           # Servidor TCP
â”œâ”€â”€ 003b-socket_cliente.py            # Cliente TCP
â”œâ”€â”€ 004a-websocket_servidor.py        # Servidor WebSocket
â”œâ”€â”€ 004b-websocket_cliente.py         # Cliente WebSocket
â”œâ”€â”€ 005-ia_remota_jocarsa.py          # IA remota
â”œâ”€â”€ 006-tame_ia_personalizada.py      # TAME IA
â”œâ”€â”€ 007-ia_ollama_python.py           # Ollama API
â”œâ”€â”€ 008-api_rest_flask.py           # API REST Flask
â”œâ”€â”€ 009a-socket_tls_servidor.py       # Servidor TLS
â”œâ”€â”€ 009b-socket_tls_cliente.py        # Cliente TLS
â”‚
â”œâ”€â”€ database_models.py                 # Modelos de base de datos
â”œâ”€â”€ metrics_prometheus.py              # Sistema de mÃ©tricas
â”œâ”€â”€ dashboard.html                     # Dashboard web
â”‚
â”œâ”€â”€ nethub.py                          # Punto de entrada principal
â”œâ”€â”€ requirements.txt                   # Dependencias
â”œâ”€â”€ .env.example                       # Ejemplo de variables de entorno
â””â”€â”€ README.md                          # Este archivo
```

**Nota:** Los siguientes archivos/carpetas se generan automÃ¡ticamente y estÃ¡n excluidos de git:
- `nethub.db` - Base de datos SQLite (se crea con `database_models.py`)
- `certs/` - Certificados TLS/SSL (se generan al iniciar servidor TLS)
- `__pycache__/` - Archivos compilados de Python
- `.env` - Variables de entorno (usar `.env.example` como plantilla)

---

## ğŸ”§ TecnologÃ­as Utilizadas

### Backend
- **Python 3.10+**: Lenguaje principal
- **Flask**: Framework web ligero
- **SQLite3**: Base de datos nativa (incluida en Python)
- **Uvicorn**: Servidor ASGI
- **WebSockets**: ComunicaciÃ³n en tiempo real

### Seguridad
- **PyJWT**: Tokens de autenticaciÃ³n
- **bcrypt**: Hash de contraseÃ±as
- **pyOpenSSL**: Certificados SSL/TLS
- **cryptography**: Operaciones criptogrÃ¡ficas

### Monitoreo
- **MÃ©tricas Vanilla**: Sistema nativo sin dependencias
- **psutil**: InformaciÃ³n del sistema (CPU, RAM)

### IA
- **Ollama Python SDK**: IA local
- **requests**: Llamadas HTTP

---

## ğŸ“ CrÃ©ditos

Proyecto desarrollado para el mÃ³dulo **ProgramaciÃ³n de Servicios y Procesos** del ciclo formativo **Desarrollo de Aplicaciones Multiplataforma (DAM-2)**.

---

## ğŸ“ Licencia

Este proyecto es de cÃ³digo abierto y estÃ¡ disponible bajo la licencia MIT.

---

## ğŸ¤ Contribuciones

Las contribuciones son bienvenidas. Por favor:

1. Fork el proyecto
2. Crea una rama para tu feature (`git checkout -b feature/AmazingFeature`)
3. Commit tus cambios (`git commit -m 'Add some AmazingFeature'`)
4. Push a la rama (`git push origin feature/AmazingFeature`)
5. Abre un Pull Request

---

## ğŸ“ Soporte

Si encuentras algÃºn problema o tienes preguntas, por favor abre un issue en el repositorio.

---

## ğŸ—ºï¸ Roadmap

### âœ… Completado (v2.0)
- [x] API REST con Flask
- [x] Dashboard web
- [x] Base de datos SQLite
- [x] AutenticaciÃ³n JWT
- [x] MÃ©tricas Vanilla (nativas)
- [x] Sockets con TLS

### ğŸš§ En Desarrollo (v2.1)
- [ ] Tests unitarios completos
- [ ] IntegraciÃ³n con Docker
- [ ] CI/CD con GitHub Actions
- [ ] DocumentaciÃ³n extendida

### ğŸ¯ Futuro (v3.0)
- [ ] Soporte para PostgreSQL/MySQL
- [ ] Clustering y balanceo de carga
- [ ] gRPC para comunicaciÃ³n entre servicios
- [ ] Frontend React/Vue

---

**Â¡Gracias por usar NetHub!** ğŸš€

```
**dashboard.html**
```html
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NetHub Dashboard - Monitoreo en Tiempo Real</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            color: white;
            margin-bottom: 30px;
        }

        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .subtitle {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .stat-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 40px rgba(0,0,0,0.3);
        }

        .stat-card h3 {
            color: #667eea;
            font-size: 0.9em;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 10px;
        }

        .stat-value {
            font-size: 2.5em;
            font-weight: bold;
            color: #333;
        }

        .stat-label {
            color: #888;
            font-size: 0.9em;
            margin-top: 5px;
        }

        .status-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 8px;
            animation: pulse 2s infinite;
        }

        .status-online {
            background: #4CAF50;
        }

        .status-offline {
            background: #f44336;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .dashboard-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        .panel {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        .panel h2 {
            color: #667eea;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid #e0e0e0;
        }

        .logs-container {
            max-height: 400px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.85em;
        }

        .log-entry {
            padding: 8px 12px;
            border-left: 3px solid #ccc;
            margin-bottom: 8px;
            background: #f9f9f9;
            border-radius: 4px;
        }

        .log-entry.INFO {
            border-left-color: #2196F3;
        }

        .log-entry.WARNING {
            border-left-color: #FF9800;
            background: #fff3e0;
        }

        .log-entry.ERROR {
            border-left-color: #f44336;
            background: #ffebee;
        }

        .log-timestamp {
            color: #666;
            font-size: 0.9em;
        }

        .log-service {
            display: inline-block;
            background: #667eea;
            color: white;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.8em;
            margin: 0 5px;
        }

        .chart-container {
            margin-top: 20px;
            height: 300px;
        }

        .login-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .login-box {
            background: white;
            padding: 40px;
            border-radius: 15px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            width: 400px;
        }

        .login-box h2 {
            color: #667eea;
            margin-bottom: 30px;
            text-align: center;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            color: #333;
            font-weight: 500;
        }

        .form-group input {
            width: 100%;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 1em;
            transition: border-color 0.3s;
        }

        .form-group input:focus {
            outline: none;
            border-color: #667eea;
        }

        .btn {
            width: 100%;
            padding: 12px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1.1em;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .btn:hover {
            transform: scale(1.02);
        }

        .btn:active {
            transform: scale(0.98);
        }

        .error-message {
            background: #ffebee;
            color: #c62828;
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: none;
        }

        .hidden {
            display: none;
        }

        .refresh-btn {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            float: right;
            margin-top: -10px;
        }

        .refresh-btn:hover {
            background: #45a049;
        }

        @media (max-width: 768px) {
            .dashboard-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <!-- Login Screen -->
    <div id="loginContainer" class="login-container">
        <div class="login-box">
            <h2>ğŸ” NetHub Login</h2>
            <div id="loginError" class="error-message"></div>
            <form id="loginForm">
                <div class="form-group">
                    <label for="username">Usuario</label>
                    <input type="text" id="username" name="username" value="admin" required>
                </div>
                <div class="form-group">
                    <label for="password">ContraseÃ±a</label>
                    <input type="password" id="password" name="password" value="admin123" required>
                </div>
                <button type="submit" class="btn">Ingresar</button>
            </form>
            <p style="text-align: center; margin-top: 20px; color: #888; font-size: 0.9em;">
                Usuario de prueba: admin / admin123
            </p>
        </div>
    </div>

    <!-- Dashboard -->
    <div id="dashboard" class="container hidden">
        <header>
            <h1>ğŸŒ NetHub Dashboard</h1>
            <p class="subtitle">Sistema de Monitoreo en Tiempo Real</p>
        </header>

        <!-- Stats Grid -->
        <div class="stats-grid">
            <div class="stat-card">
                <h3>Estado del Sistema</h3>
                <div class="stat-value">
                    <span class="status-indicator status-online"></span>
                    <span id="systemStatus">Online</span>
                </div>
                <div class="stat-label">API activa</div>
            </div>

            <div class="stat-card">
                <h3>Conexiones Activas</h3>
                <div class="stat-value" id="activeConnections">0</div>
                <div class="stat-label">En tiempo real</div>
            </div>

            <div class="stat-card">
                <h3>Total Mensajes</h3>
                <div class="stat-value" id="totalMessages">0</div>
                <div class="stat-label">Enviados/Recibidos</div>
            </div>

            <div class="stat-card">
                <h3>Total Logs</h3>
                <div class="stat-value" id="totalLogs">0</div>
                <div class="stat-label">Registros</div>
            </div>
        </div>

        <!-- Dashboard Grid -->
        <div class="dashboard-grid">
            <!-- Logs Panel -->
            <div class="panel">
                <h2>
                    Logs del Sistema
                    <button class="refresh-btn" onclick="cargarLogs()">ğŸ”„ Actualizar</button>
                </h2>
                <div class="logs-container" id="logsContainer">
                    <p style="text-align: center; color: #888;">Cargando logs...</p>
                </div>
            </div>

            <!-- Stats Panel -->
            <div class="panel">
                <h2>EstadÃ­sticas por Servicio</h2>
                <canvas id="serviceChart"></canvas>
            </div>

            <!-- Messages Panel -->
            <div class="panel">
                <h2>MÃ©tricas de Red</h2>
                <div id="metricsContainer">
                    <p><strong>Logs por Nivel:</strong></p>
                    <div id="logsByLevel"></div>
                    <p style="margin-top: 20px;"><strong>Logs por Servicio:</strong></p>
                    <div id="logsByService"></div>
                </div>
            </div>

            <!-- Quick Actions -->
            <div class="panel">
                <h2>Acciones RÃ¡pidas</h2>
                <button class="btn" onclick="window.open('/api/docs', '_blank')" style="margin-bottom: 10px;">
                    ğŸ“š Ver DocumentaciÃ³n API
                </button>
                <button class="btn" onclick="window.open('/metrics', '_blank')" style="margin-bottom: 10px; background: #FF9800;">
                    ğŸ“Š Ver MÃ©tricas (JSON)
                </button>
                <button class="btn" onclick="limpiarLogs()" style="background: #f44336;">
                    ğŸ—‘ï¸ Limpiar Logs
                </button>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script>
        // Variables globales
        let token = null;
        let updateInterval = null;

        // Login
        document.getElementById('loginForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            
            const username = document.getElementById('username').value;
            const password = document.getElementById('password').value;
            const errorDiv = document.getElementById('loginError');
            
            try {
                const response = await fetch('/api/auth/login', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ username, password })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    token = data.access_token;
                    
                    // Guardar token
                    localStorage.setItem('nethub_token', token);
                    
                    // Mostrar dashboard
                    document.getElementById('loginContainer').classList.add('hidden');
                    document.getElementById('dashboard').classList.remove('hidden');
                    
                    // Iniciar actualizaciones
                    inicializarDashboard();
                } else {
                    errorDiv.textContent = 'Credenciales incorrectas';
                    errorDiv.style.display = 'block';
                }
            } catch (error) {
                errorDiv.textContent = 'Error de conexiÃ³n';
                errorDiv.style.display = 'block';
            }
        });

        // Verificar token al cargar
        window.addEventListener('load', async () => {
            const savedToken = localStorage.getItem('nethub_token');
            if (savedToken) {
                token = savedToken;
                
                // Verificar si el token es vÃ¡lido
                try {
                    const response = await fetch('/api/auth/verify', {
                        headers: {
                            'Authorization': `Bearer ${token}`
                        }
                    });
                    
                    if (response.ok) {
                        document.getElementById('loginContainer').classList.add('hidden');
                        document.getElementById('dashboard').classList.remove('hidden');
                        inicializarDashboard();
                    } else {
                        localStorage.removeItem('nethub_token');
                    }
                } catch (error) {
                    localStorage.removeItem('nethub_token');
                }
            }
        });

        // Inicializar dashboard
        function inicializarDashboard() {
            cargarEstadisticas();
            cargarLogs();
            
            // Actualizar cada 5 segundos
            updateInterval = setInterval(() => {
                cargarEstadisticas();
                cargarLogs();
            }, 5000);
        }

        // Cargar estadÃ­sticas
        async function cargarEstadisticas() {
            try {
                const response = await fetch('/api/stats', {
                    headers: {
                        'Authorization': `Bearer ${token}`
                    }
                });
                
                if (response.ok) {
                    const data = await response.json();
                    
                    document.getElementById('totalLogs').textContent = data.total_logs;
                    document.getElementById('totalMessages').textContent = data.total_mensajes;
                    document.getElementById('activeConnections').textContent = data.total_conexiones;
                    
                    // Actualizar mÃ©tricas
                    actualizarMetricas(data);
                }
            } catch (error) {
                console.error('Error cargando estadÃ­sticas:', error);
            }
        }

        // Cargar logs
        async function cargarLogs() {
            try {
                const response = await fetch('/api/logs?limite=20', {
                    headers: {
                        'Authorization': `Bearer ${token}`
                    }
                });
                
                if (response.ok) {
                    const logs = await response.json();
                    const container = document.getElementById('logsContainer');
                    
                    if (logs.length === 0) {
                        container.innerHTML = '<p style="text-align: center; color: #888;">No hay logs</p>';
                        return;
                    }
                    
                    container.innerHTML = logs.map(log => `
                        <div class="log-entry ${log.nivel}">
                            <span class="log-timestamp">${new Date(log.timestamp).toLocaleString('es-ES')}</span>
                            <span class="log-service">${log.servicio}</span>
                            <strong>${log.nivel}</strong>: ${log.mensaje}
                        </div>
                    `).join('');
                }
            } catch (error) {
                console.error('Error cargando logs:', error);
            }
        }

        // Actualizar mÃ©tricas
        function actualizarMetricas(data) {
            // Logs por nivel
            const levelDiv = document.getElementById('logsByLevel');
            if (data.logs_por_nivel) {
                levelDiv.innerHTML = Object.entries(data.logs_por_nivel)
                    .map(([nivel, count]) => `<p>â€¢ ${nivel}: <strong>${count}</strong></p>`)
                    .join('');
            }
            
            // Logs por servicio
            const serviceDiv = document.getElementById('logsByService');
            if (data.logs_por_servicio) {
                serviceDiv.innerHTML = Object.entries(data.logs_por_servicio)
                    .map(([servicio, count]) => `<p>â€¢ ${servicio}: <strong>${count}</strong></p>`)
                    .join('');
            }
        }

        // Limpiar logs
        async function limpiarLogs() {
            if (!confirm('Â¿EstÃ¡s seguro de eliminar todos los logs?')) {
                return;
            }
            
            try {
                const response = await fetch('/api/logs/clear', {
                    method: 'DELETE',
                    headers: {
                        'Authorization': `Bearer ${token}`
                    }
                });
                
                if (response.ok) {
                    alert('Logs eliminados correctamente');
                    cargarLogs();
                    cargarEstadisticas();
                } else {
                    alert('Error al eliminar logs');
                }
            } catch (error) {
                alert('Error de conexiÃ³n');
            }
        }
    </script>
</body>
</html>

```
**database_models.py**
```python
#!/usr/bin/env python3
"""
====================================================
  MÃ“DULO - BASE DE DATOS SQLite (Nativo)
====================================================
Define las funciones de base de datos para logs, mensajes,
conexiones y usuarios. Utiliza SQLite3 nativo (sin ORM).
====================================================
"""

import sqlite3
from datetime import datetime, timedelta
from typing import Generator, Any
from contextlib import contextmanager
import threading

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#  CONFIGURACIÃ“N DE BASE DE DATOS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

DATABASE_FILE = "nethub.db"

# Thread-local storage para conexiones
_thread_local = threading.local()


def get_connection() -> sqlite3.Connection:
    """Obtener conexiÃ³n SQLite (una por thread)."""
    if not hasattr(_thread_local, 'conn') or _thread_local.conn is None:
        _thread_local.conn = sqlite3.connect(
            DATABASE_FILE,
            check_same_thread=False,
            detect_types=sqlite3.PARSE_DECLTYPES | sqlite3.PARSE_COLNAMES
        )
        _thread_local.conn.row_factory = sqlite3.Row  # Acceso por nombre de columna
    return _thread_local.conn


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#  CLASES MODELO (Simplificadas)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class Log:
    """RepresentaciÃ³n de un log."""
    def __init__(self, row: sqlite3.Row):
        self.id = row['id']
        self.timestamp = datetime.fromisoformat(row['timestamp']) if row['timestamp'] else None
        self.nivel = row['nivel']
        self.servicio = row['servicio']
        self.mensaje = row['mensaje']
        self.ip_origen = row['ip_origen']
        self.usuario = row['usuario']


class Message:
    """RepresentaciÃ³n de un mensaje."""
    def __init__(self, row: sqlite3.Row):
        self.id = row['id']
        self.timestamp = datetime.fromisoformat(row['timestamp']) if row['timestamp'] else None
        self.tipo = row['tipo']
        self.remitente = row['remitente']
        self.destinatario = row['destinatario']
        self.asunto = row['asunto']
        self.contenido = row['contenido']
        self.estado = row['estado']
        self.tamano_bytes = row['tamano_bytes']


class Connection:
    """RepresentaciÃ³n de una conexiÃ³n."""
    def __init__(self, row: sqlite3.Row):
        self.id = row['id']
        self.timestamp_inicio = datetime.fromisoformat(row['timestamp_inicio']) if row['timestamp_inicio'] else None
        self.timestamp_fin = datetime.fromisoformat(row['timestamp_fin']) if row['timestamp_fin'] else None
        self.tipo = row['tipo']
        self.ip_cliente = row['ip_cliente']
        self.puerto_cliente = row['puerto_cliente']
        self.ip_servidor = row['ip_servidor']
        self.puerto_servidor = row['puerto_servidor']
        self.estado = row['estado']
        self.bytes_enviados = row['bytes_enviados']
        self.bytes_recibidos = row['bytes_recibidos']


class DatabaseSession:
    """SesiÃ³n de base de datos (simulaciÃ³n de SQLAlchemy Session)."""
    def __init__(self, conn: sqlite3.Connection):
        self.conn = conn
        self.cursor = conn.cursor()
    
    def execute(self, query: str, params: tuple = ()):
        """Ejecutar consulta SQL."""
        return self.cursor.execute(query, params)
    
    def commit(self):
        """Confirmar transacciÃ³n."""
        self.conn.commit()
    
    def rollback(self):
        """Revertir transacciÃ³n."""
        self.conn.rollback()
    
    def close(self):
        """Cerrar cursor (conexiÃ³n se mantiene en thread local)."""
        if self.cursor:
            self.cursor.close()


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#  FUNCIONES DE UTILIDAD
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def crear_tablas():
    """Crear todas las tablas en la base de datos."""
    conn = get_connection()
    cursor = conn.cursor()
    
    # Tabla de logs
    cursor.execute("""
        CREATE TABLE IF NOT EXISTS logs (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            timestamp TEXT NOT NULL DEFAULT (datetime('now')),
            nivel TEXT NOT NULL,
            servicio TEXT NOT NULL,
            mensaje TEXT NOT NULL,
            ip_origen TEXT,
            usuario TEXT
        )
    """)
    
    cursor.execute("CREATE INDEX IF NOT EXISTS idx_logs_timestamp ON logs(timestamp)")
    cursor.execute("CREATE INDEX IF NOT EXISTS idx_logs_nivel ON logs(nivel)")
    cursor.execute("CREATE INDEX IF NOT EXISTS idx_logs_servicio ON logs(servicio)")
    
    # Tabla de mensajes
    cursor.execute("""
        CREATE TABLE IF NOT EXISTS messages (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            timestamp TEXT NOT NULL DEFAULT (datetime('now')),
            tipo TEXT NOT NULL,
            remitente TEXT NOT NULL,
            destinatario TEXT NOT NULL,
            asunto TEXT,
            contenido TEXT,
            estado TEXT NOT NULL,
            tamano_bytes INTEGER
        )
    """)
    
    cursor.execute("CREATE INDEX IF NOT EXISTS idx_messages_timestamp ON messages(timestamp)")
    cursor.execute("CREATE INDEX IF NOT EXISTS idx_messages_tipo ON messages(tipo)")
    
    # Tabla de conexiones
    cursor.execute("""
        CREATE TABLE IF NOT EXISTS connections (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            timestamp_inicio TEXT NOT NULL DEFAULT (datetime('now')),
            timestamp_fin TEXT,
            tipo TEXT NOT NULL,
            ip_cliente TEXT NOT NULL,
            puerto_cliente INTEGER NOT NULL,
            ip_servidor TEXT NOT NULL,
            puerto_servidor INTEGER NOT NULL,
            estado TEXT NOT NULL,
            bytes_enviados INTEGER DEFAULT 0,
            bytes_recibidos INTEGER DEFAULT 0
        )
    """)
    
    cursor.execute("CREATE INDEX IF NOT EXISTS idx_connections_timestamp ON connections(timestamp_inicio)")
    cursor.execute("CREATE INDEX IF NOT EXISTS idx_connections_tipo ON connections(tipo)")
    
    # Tabla de usuarios
    cursor.execute("""
        CREATE TABLE IF NOT EXISTS usuarios (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            username TEXT UNIQUE NOT NULL,
            email TEXT UNIQUE NOT NULL,
            password_hash TEXT NOT NULL,
            activo INTEGER DEFAULT 1,
            es_admin INTEGER DEFAULT 0,
            fecha_creacion TEXT NOT NULL DEFAULT (datetime('now')),
            ultimo_acceso TEXT
        )
    """)
    
    cursor.execute("CREATE INDEX IF NOT EXISTS idx_usuarios_username ON usuarios(username)")
    cursor.execute("CREATE INDEX IF NOT EXISTS idx_usuarios_email ON usuarios(email)")
    
    # Tabla de mÃ©tricas
    cursor.execute("""
        CREATE TABLE IF NOT EXISTS metricas (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            timestamp TEXT NOT NULL DEFAULT (datetime('now')),
            nombre_metrica TEXT NOT NULL,
            valor TEXT NOT NULL,
            etiquetas TEXT
        )
    """)
    
    cursor.execute("CREATE INDEX IF NOT EXISTS idx_metricas_timestamp ON metricas(timestamp)")
    cursor.execute("CREATE INDEX IF NOT EXISTS idx_metricas_nombre ON metricas(nombre_metrica)")
    
    conn.commit()
    print("[DB] âœ… Tablas creadas/verificadas correctamente")


def get_db() -> Generator[DatabaseSession, None, None]:
    """
    Dependency para FastAPI que proporciona una sesiÃ³n de BD.
    Se cierra automÃ¡ticamente al finalizar.
    """
    conn = get_connection()
    db = DatabaseSession(conn)
    try:
        yield db
    except Exception:
        db.rollback()
        raise
    finally:
        db.close()


def SessionLocal() -> DatabaseSession:
    """
    Crear una nueva sesiÃ³n de base de datos (compatibilidad con cÃ³digo antiguo).
    IMPORTANTE: Debe cerrarse manualmente con db.close()
    """
    conn = get_connection()
    return DatabaseSession(conn)


def crear_log(
    db: DatabaseSession, 
    nivel: str, 
    servicio: str, 
    mensaje: str,
    ip_origen: str = None,
    usuario: str = None
) -> dict:
    """Crear un registro de log en la base de datos."""
    db.execute(
        """INSERT INTO logs (nivel, servicio, mensaje, ip_origen, usuario) 
           VALUES (?, ?, ?, ?, ?)""",
        (nivel, servicio, mensaje, ip_origen, usuario)
    )
    db.commit()
    return {"id": db.cursor.lastrowid, "nivel": nivel, "servicio": servicio}


def crear_mensaje(
    db: DatabaseSession,
    tipo: str,
    remitente: str,
    destinatario: str,
    asunto: str = None,
    contenido: str = None,
    estado: str = "ENVIADO"
) -> dict:
    """Crear un registro de mensaje."""
    tamano_bytes = len(contenido) if contenido else 0
    
    db.execute(
        """INSERT INTO messages (tipo, remitente, destinatario, asunto, contenido, estado, tamano_bytes) 
           VALUES (?, ?, ?, ?, ?, ?, ?)""",
        (tipo, remitente, destinatario, asunto, contenido, estado, tamano_bytes)
    )
    db.commit()
    return {"id": db.cursor.lastrowid, "tipo": tipo}


def crear_conexion(
    db: DatabaseSession,
    tipo: str,
    ip_cliente: str,
    puerto_cliente: int,
    ip_servidor: str,
    puerto_servidor: int,
    estado: str = "ACTIVA"
) -> dict:
    """Registrar una nueva conexiÃ³n."""
    db.execute(
        """INSERT INTO connections (tipo, ip_cliente, puerto_cliente, ip_servidor, puerto_servidor, estado) 
           VALUES (?, ?, ?, ?, ?, ?)""",
        (tipo, ip_cliente, puerto_cliente, ip_servidor, puerto_servidor, estado)
    )
    db.commit()
    return {"id": db.cursor.lastrowid, "tipo": tipo, "estado": estado}


def cerrar_conexion(
    db: DatabaseSession,
    conexion_id: int,
    bytes_enviados: int = 0,
    bytes_recibidos: int = 0
):
    """Marcar una conexiÃ³n como cerrada."""
    db.execute(
        """UPDATE connections 
           SET timestamp_fin = datetime('now'), estado = 'CERRADA', 
               bytes_enviados = ?, bytes_recibidos = ?
           WHERE id = ?""",
        (bytes_enviados, bytes_recibidos, conexion_id)
    )
    db.commit()


def obtener_ultimos_logs(db: DatabaseSession, limite: int = 50, servicio: str = None) -> list[Log]:
    """Obtener los Ãºltimos logs del sistema."""
    if servicio:
        rows = db.execute(
            "SELECT * FROM logs WHERE servicio = ? ORDER BY timestamp DESC LIMIT ?",
            (servicio, limite)
        ).fetchall()
    else:
        rows = db.execute(
            "SELECT * FROM logs ORDER BY timestamp DESC LIMIT ?",
            (limite,)
        ).fetchall()
    return [Log(row) for row in rows]


def obtener_logs_por_nivel(db: DatabaseSession) -> dict:
    """Obtener conteo de logs agrupados por nivel."""
    rows = db.execute(
        "SELECT nivel, COUNT(*) as count FROM logs GROUP BY nivel"
    ).fetchall()
    return {row['nivel']: row['count'] for row in rows}


def obtener_logs_por_servicio(db: DatabaseSession) -> dict:
    """Obtener conteo de logs agrupados por servicio."""
    rows = db.execute(
        "SELECT servicio, COUNT(*) as count FROM logs GROUP BY servicio"
    ).fetchall()
    return {row['servicio']: row['count'] for row in rows}


def obtener_estadisticas(db: DatabaseSession) -> dict:
    """Obtener estadÃ­sticas generales del sistema."""
    stats = {}
    
    stats['total_logs'] = db.execute("SELECT COUNT(*) as count FROM logs").fetchone()['count']
    stats['total_mensajes'] = db.execute("SELECT COUNT(*) as count FROM messages").fetchone()['count']
    stats['total_conexiones'] = db.execute("SELECT COUNT(*) as count FROM connections").fetchone()['count']
    stats['conexiones_activas'] = db.execute(
        "SELECT COUNT(*) as count FROM connections WHERE estado = 'ACTIVA'"
    ).fetchone()['count']
    stats['errores_recientes'] = db.execute(
        "SELECT COUNT(*) as count FROM logs WHERE nivel = 'ERROR'"
    ).fetchone()['count']
    
    return stats


def limpiar_logs_antiguos(db: DatabaseSession, dias: int = 30) -> int:
    """Eliminar logs mÃ¡s antiguos que X dÃ­as."""
    fecha_limite = (datetime.utcnow() - timedelta(days=dias)).isoformat()
    
    result = db.execute(
        "DELETE FROM logs WHERE timestamp < ?",
        (fecha_limite,)
    )
    db.commit()
    
    return result.rowcount


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#  FUNCIONES DE USUARIOS Y AUTENTICACIÃ“N
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def obtener_usuario_por_username(db: DatabaseSession, username: str) -> dict | None:
    """Obtener usuario por nombre de usuario."""
    row = db.execute(
        "SELECT * FROM usuarios WHERE username = ?",
        (username,)
    ).fetchone()
    
    if row:
        return {
            'id': row['id'],
            'username': row['username'],
            'email': row['email'],
            'password_hash': row['password_hash'],
            'activo': bool(row['activo']),
            'es_admin': bool(row['es_admin']),
            'fecha_creacion': row['fecha_creacion'],
            'ultimo_acceso': row['ultimo_acceso']
        }
    return None


def verificar_password(password: str, password_hash: str) -> bool:
    """Verificar contraseÃ±a contra hash almacenado."""
    try:
        import bcrypt
        return bcrypt.checkpw(password.encode('utf-8'), password_hash.encode('utf-8'))
    except ImportError:
        # Fallback a hash simple
        import hashlib
        hash_simple = hashlib.sha256(password.encode('utf-8')).hexdigest()
        return hash_simple == password_hash


def actualizar_ultimo_acceso(db: DatabaseSession, username: str):
    """Actualizar timestamp del Ãºltimo acceso del usuario."""
    db.execute(
        "UPDATE usuarios SET ultimo_acceso = datetime('now') WHERE username = ?",
        (username,)
    )
    db.commit()


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#  INICIALIZACIÃ“N
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def inicializar_base_datos():
    """Inicializar la base de datos con datos por defecto."""
    crear_tablas()
    
    conn = get_connection()
    db = DatabaseSession(conn)
    
    try:
        # Verificar si ya hay usuarios
        count = db.execute("SELECT COUNT(*) as count FROM usuarios").fetchone()['count']
        
        if count == 0:
            # Crear usuario admin por defecto
            try:
                import bcrypt
                password_hash = bcrypt.hashpw(
                    "admin123".encode('utf-8'), 
                    bcrypt.gensalt()
                ).decode('utf-8')
            except ImportError:
                # Si bcrypt no estÃ¡ instalado, usar hash simple (NO USAR EN PRODUCCIÃ“N)
                import hashlib
                password_hash = hashlib.sha256("admin123".encode('utf-8')).hexdigest()
                print("[DB] âš ï¸  bcrypt no instalado - usando hash bÃ¡sico (instala bcrypt para producciÃ³n)")
            
            db.execute(
                """INSERT INTO usuarios (username, email, password_hash, activo, es_admin) 
                   VALUES (?, ?, ?, 1, 1)""",
                ("admin", "admin@nethub.local", password_hash)
            )
            
            # Log inicial
            crear_log(
                db, 
                "INFO", 
                "Sistema", 
                "Base de datos inicializada correctamente"
            )
            
            db.commit()
            print("[DB] âœ… Usuario admin creado (usuario: admin, password: admin123)")
        
    finally:
        db.close()


if __name__ == "__main__":
    print("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—")
    print("â•‘     NetHub - InicializaciÃ³n de Base de Datos    â•‘")
    print("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
    print()
    
    inicializar_base_datos()
    
    # Mostrar estadÃ­sticas
    conn = get_connection()
    db = DatabaseSession(conn)
    try:
        stats = obtener_estadisticas(db)
        print("\nğŸ“Š EstadÃ­sticas:")
        for clave, valor in stats.items():
            print(f"   â€¢ {clave}: {valor}")
    finally:
        db.close()
    
    print("\nâœ… Base de datos lista para usar")

```
**metrics_prometheus.py**
```python
#!/usr/bin/env python3
"""
====================================================
  MÃ“DULO - MÃ‰TRICAS VANILLA (SIN DEPENDENCIAS)
====================================================
Sistema de mÃ©tricas nativo para monitoreo.
Recopila estadÃ­sticas de uso, rendimiento y errores
sin dependencias externas.
====================================================
"""

from functools import wraps
from threading import Lock
import time
import json
from typing import Callable, Dict, List, Any
from collections import defaultdict

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#  CLASES DE MÃ‰TRICAS VANILLA
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class Counter:
    """Contador simple thread-safe."""
    
    def __init__(self, name: str, description: str, labels: List[str] = None):
        self.name = name
        self.description = description
        self.labels = labels or []
        self._values = defaultdict(int)
        self._lock = Lock()
    
    def labels(self, **kwargs):
        """Retorna un contador con labels especÃ­ficos."""
        return LabeledCounter(self, **kwargs)
    
    def inc(self, amount=1, **label_values):
        """Incrementar el contador."""
        with self._lock:
            key = tuple(sorted(label_values.items()))
            self._values[key] += amount
    
    def get_value(self, **label_values):
        """Obtener valor actual."""
        key = tuple(sorted(label_values.items()))
        return self._values.get(key, 0)
    
    def get_all(self):
        """Obtener todos los valores."""
        return dict(self._values)


class LabeledCounter:
    """Contador con labels pre-establecidos."""
    
    def __init__(self, counter: Counter, **labels):
        self.counter = counter
        self.labels = labels
    
    def inc(self, amount=1):
        """Incrementar."""
        self.counter.inc(amount, **self.labels)


class Gauge:
    """Gauge simple thread-safe."""
    
    def __init__(self, name: str, description: str, labels: List[str] = None):
        self.name = name
        self.description = description
        self.labels = labels or []
        self._values = defaultdict(float)
        self._lock = Lock()
    
    def labels(self, **kwargs):
        """Retorna un gauge con labels especÃ­ficos."""
        return LabeledGauge(self, **kwargs)
    
    def set(self, value, **label_values):
        """Establecer valor."""
        with self._lock:
            key = tuple(sorted(label_values.items()))
            self._values[key] = float(value)
    
    def inc(self, amount=1, **label_values):
        """Incrementar."""
        with self._lock:
            key = tuple(sorted(label_values.items()))
            self._values[key] = self._values.get(key, 0) + amount
    
    def dec(self, amount=1, **label_values):
        """Decrementar."""
        with self._lock:
            key = tuple(sorted(label_values.items()))
            self._values[key] = self._values.get(key, 0) - amount
    
    def get_value(self, **label_values):
        """Obtener valor actual."""
        key = tuple(sorted(label_values.items()))
        return self._values.get(key, 0)
    
    def get_all(self):
        """Obtener todos los valores."""
        return dict(self._values)


class LabeledGauge:
    """Gauge con labels pre-establecidos."""
    
    def __init__(self, gauge: Gauge, **labels):
        self.gauge = gauge
        self.labels = labels
    
    def set(self, value):
        """Establecer valor."""
        self.gauge.set(value, **self.labels)
    
    def inc(self, amount=1):
        """Incrementar."""
        self.gauge.inc(amount, **self.labels)
    
    def dec(self, amount=1):
        """Decrementar."""
        self.gauge.dec(amount, **self.labels)


class Histogram:
    """Histograma simple para medir duraciones."""
    
    def __init__(self, name: str, description: str, labels: List[str] = None):
        self.name = name
        self.description = description
        self.labels = labels or []
        self._observations = defaultdict(list)
        self._lock = Lock()
    
    def labels(self, **kwargs):
        """Retorna un histograma con labels especÃ­ficos."""
        return LabeledHistogram(self, **kwargs)
    
    def observe(self, value, **label_values):
        """Registrar una observaciÃ³n."""
        with self._lock:
            key = tuple(sorted(label_values.items()))
            self._observations[key].append(float(value))
    
    def get_stats(self, **label_values):
        """Obtener estadÃ­sticas (count, sum, avg, min, max)."""
        key = tuple(sorted(label_values.items()))
        observations = self._observations.get(key, [])
        
        if not observations:
            return {"count": 0, "sum": 0, "avg": 0, "min": 0, "max": 0}
        
        return {
            "count": len(observations),
            "sum": sum(observations),
            "avg": sum(observations) / len(observations),
            "min": min(observations),
            "max": max(observations)
        }
    
    def get_all(self):
        """Obtener todas las estadÃ­sticas."""
        result = {}
        for key, observations in self._observations.items():
            labels_dict = dict(key) if key else {}
            stats = self.get_stats(**labels_dict)
            result[str(labels_dict)] = stats
        return result


class LabeledHistogram:
    """Histograma con labels pre-establecidos."""
    
    def __init__(self, histogram: Histogram, **labels):
        self.histogram = histogram
        self.labels = labels
    
    def observe(self, value):
        """Registrar observaciÃ³n."""
        self.histogram.observe(value, **self.labels)


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#  DEFINICIÃ“N DE MÃ‰TRICAS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Contador de peticiones HTTP por endpoint
REQUEST_COUNT = Counter(
    'nethub_http_requests_total',
    'Total de peticiones HTTP recibidas',
    ['method', 'endpoint', 'status']
)

# Histograma de latencia de peticiones
REQUEST_LATENCY = Histogram(
    'nethub_request_duration_seconds',
    'DuraciÃ³n de peticiones HTTP en segundos',
    ['endpoint']
)

# Contador de errores por servicio
ERRORS_COUNT = Counter(
    'nethub_errors_total',
    'Total de errores por servicio',
    ['service', 'error_type']
)

# Gauge de conexiones activas
ACTIVE_CONNECTIONS = Gauge(
    'nethub_active_connections',
    'NÃºmero de conexiones activas',
    ['connection_type']
)

# Contador de mensajes enviados
MESSAGES_SENT = Counter(
    'nethub_messages_sent_total',
    'Total de mensajes enviados',
    ['message_type']
)

# Contador de mensajes recibidos
MESSAGES_RECEIVED = Counter(
    'nethub_messages_received_total',
    'Total de mensajes recibidos',
    ['message_type']
)

# Gauge de bytes transferidos
BYTES_TRANSFERRED = Gauge(
    'nethub_bytes_transferred',
    'Bytes transferidos',
    ['direction']  # sent/received
)

# Contador de autenticaciones
AUTH_ATTEMPTS = Counter(
    'nethub_auth_attempts_total',
    'Intentos de autenticaciÃ³n',
    ['status']  # success/failure
)

# Histograma de tiempo de respuesta de IA
IA_RESPONSE_TIME = Histogram(
    'nethub_ia_response_seconds',
    'Tiempo de respuesta de consultas a IA',
    ['model']
)

# Gauge de uso de recursos
SYSTEM_CPU_USAGE = Gauge(
    'nethub_system_cpu_percent',
    'Uso de CPU del sistema',
    []
)

SYSTEM_MEMORY_USAGE = Gauge(
    'nethub_system_memory_bytes',
    'Uso de memoria del sistema en bytes',
    []
)

# Contador de operaciones de base de datos
DATABASE_OPERATIONS = Counter(
    'nethub_database_operations_total',
    'Operaciones de base de datos',
    ['operation', 'table']
)

# Registro global de todas las mÃ©tricas
METRICS_REGISTRY = {
    'REQUEST_COUNT': REQUEST_COUNT,
    'REQUEST_LATENCY': REQUEST_LATENCY,
    'ERRORS_COUNT': ERRORS_COUNT,
    'ACTIVE_CONNECTIONS': ACTIVE_CONNECTIONS,
    'MESSAGES_SENT': MESSAGES_SENT,
    'MESSAGES_RECEIVED': MESSAGES_RECEIVED,
    'BYTES_TRANSFERRED': BYTES_TRANSFERRED,
    'AUTH_ATTEMPTS': AUTH_ATTEMPTS,
    'IA_RESPONSE_TIME': IA_RESPONSE_TIME,
    'SYSTEM_CPU_USAGE': SYSTEM_CPU_USAGE,
    'SYSTEM_MEMORY_USAGE': SYSTEM_MEMORY_USAGE,
    'DATABASE_OPERATIONS': DATABASE_OPERATIONS,
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#  DECORADORES PARA TRACKING AUTOMÃTICO
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def track_request(endpoint: str):
    """
    Decorador para trackear mÃ©tricas de una peticiÃ³n.
    
    Uso:
        @track_request("login")
        async def login(request):
            ...
    """
    def decorator(func: Callable) -> Callable:
        @wraps(func)
        async def wrapper(*args, **kwargs):
            start_time = time.time()
            
            try:
                result = await func(*args, **kwargs)
                
                # Registrar peticiÃ³n exitosa
                duration = time.time() - start_time
                REQUEST_LATENCY.labels(endpoint=endpoint).observe(duration)
                REQUEST_COUNT.labels(
                    method="POST",  # Asumiendo POST, ajustar segÃºn necesidad
                    endpoint=endpoint,
                    status="200"
                ).inc()
                
                return result
                
            except Exception as e:
                # Registrar error
                duration = time.time() - start_time
                REQUEST_LATENCY.labels(endpoint=endpoint).observe(duration)
                REQUEST_COUNT.labels(
                    method="POST",
                    endpoint=endpoint,
                    status="500"
                ).inc()
                
                ERRORS_COUNT.labels(
                    service=endpoint,
                    error_type=type(e).__name__
                ).inc()
                
                raise
        
        return wrapper
    return decorator


def track_ia_query(model: str):
    """Decorador para trackear consultas a IA."""
    def decorator(func: Callable) -> Callable:
        @wraps(func)
        async def wrapper(*args, **kwargs):
            start_time = time.time()
            
            try:
                result = await func(*args, **kwargs)
                duration = time.time() - start_time
                IA_RESPONSE_TIME.labels(model=model).observe(duration)
                return result
            except Exception as e:
                ERRORS_COUNT.labels(
                    service="ia",
                    error_type=type(e).__name__
                ).inc()
                raise
        
        return wrapper
    return decorator


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#  FUNCIONES DE UTILIDAD
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def registrar_mensaje_enviado(tipo: str):
    """Registrar un mensaje enviado."""
    MESSAGES_SENT.inc(message_type=tipo)


def registrar_mensaje_recibido(tipo: str):
    """Registrar un mensaje recibido."""
    MESSAGES_RECEIVED.inc(message_type=tipo)


def registrar_bytes(direccion: str, cantidad: int):
    """Registrar bytes transferidos."""
    BYTES_TRANSFERRED.set(cantidad, direction=direccion)


def registrar_autenticacion(exitosa: bool):
    """Registrar intento de autenticaciÃ³n."""
    status = "success" if exitosa else "failure"
    AUTH_ATTEMPTS.inc(status=status)


def actualizar_conexiones_activas(tipo: str, cantidad: int):
    """Actualizar nÃºmero de conexiones activas."""
    ACTIVE_CONNECTIONS.set(cantidad, connection_type=tipo)


def registrar_operacion_bd(operacion: str, tabla: str):
    """Registrar operaciÃ³n de base de datos."""
    DATABASE_OPERATIONS.inc(operation=operacion, table=tabla)


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#  MONITOREO DE SISTEMA
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def actualizar_metricas_sistema():
    """Actualizar mÃ©tricas de uso del sistema."""
    try:
        import psutil
        
        # CPU
        cpu_percent = psutil.cpu_percent(interval=1)
        SYSTEM_CPU_USAGE.set(cpu_percent)
        
        # Memoria
        memoria = psutil.virtual_memory()
        SYSTEM_MEMORY_USAGE.set(memoria.used)
        
    except ImportError:
        # psutil no instalado, mÃ©tricas del sistema no disponibles
        pass


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#  EXPORTACIÃ“N DE MÃ‰TRICAS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def obtener_metricas() -> str:
    """
    Obtener las mÃ©tricas en formato JSON.
    
    Returns:
        str: MÃ©tricas en formato JSON
    """
    actualizar_metricas_sistema()
    
    metricas = {}
    
    for nombre, metrica in METRICS_REGISTRY.items():
        if isinstance(metrica, (Counter, Gauge)):
            metricas[metrica.name] = {
                "description": metrica.description,
                "type": "counter" if isinstance(metrica, Counter) else "gauge",
                "values": {}
            }
            
            # Convertir valores
            for key, value in metrica.get_all().items():
                labels_dict = dict(key) if key else {}
                label_str = json.dumps(labels_dict, sort_keys=True) if labels_dict else "no_labels"
                metricas[metrica.name]["values"][label_str] = value
                
        elif isinstance(metrica, Histogram):
            metricas[metrica.name] = {
                "description": metrica.description,
                "type": "histogram",
                "values": metrica.get_all()
            }
    
    return json.dumps(metricas, indent=2, ensure_ascii=False)


def obtener_metricas_dict() -> dict:
    """
    Obtener las mÃ©tricas como diccionario Python.
    
    Returns:
        dict: MÃ©tricas en formato diccionario
    """
    actualizar_metricas_sistema()
    
    metricas = {}
    
    for nombre, metrica in METRICS_REGISTRY.items():
        if isinstance(metrica, (Counter, Gauge)):
            valores = {}
            for key, value in metrica.get_all().items():
                labels_dict = dict(key) if key else {}
                label_str = json.dumps(labels_dict, sort_keys=True) if labels_dict else "no_labels"
                valores[label_str] = value
            
            metricas[metrica.name] = {
                "description": metrica.description,
                "type": "counter" if isinstance(metrica, Counter) else "gauge",
                "values": valores
            }
                
        elif isinstance(metrica, Histogram):
            metricas[metrica.name] = {
                "description": metrica.description,
                "type": "histogram",
                "values": metrica.get_all()
            }
    
    return metricas


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#  CLASE PARA CONTEXTO
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class MetricaContexto:
    """
    Context manager para medir duraciÃ³n de operaciones.
    
    Uso:
        with MetricaContexto(REQUEST_LATENCY, endpoint="login"):
            # cÃ³digo a medir
            hacer_operacion()
    """
    
    def __init__(self, metrica: Histogram, **labels):
        self.metrica = metrica
        self.labels = labels
        self.start_time = None
    
    def __enter__(self):
        self.start_time = time.time()
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        duration = time.time() - self.start_time
        self.metrica.observe(duration, **self.labels)


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#  CONFIGURACIÃ“N INICIAL
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def inicializar_metricas():
    """Inicializar valores por defecto de las mÃ©tricas."""
    # Inicializar conexiones en 0
    for tipo in ['tcp', 'websocket', 'http', 'tcp_tls']:
        ACTIVE_CONNECTIONS.set(0, connection_type=tipo)
    
    # Inicializar bytes transferidos en 0
    for direccion in ['sent', 'received']:
        BYTES_TRANSFERRED.set(0, direction=direccion)
    
    print("[MÃ©tricas] âœ… Sistema de mÃ©tricas vanilla inicializado")


if __name__ == "__main__":
    print("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—")
    print("â•‘       NetHub - Sistema de MÃ©tricas Vanilla      â•‘")
    print("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
    print()
    
    inicializar_metricas()
    
    # Ejemplo de uso
    print("ğŸ“Š MÃ©tricas disponibles:")
    print("   â€¢ nethub_http_requests_total")
    print("   â€¢ nethub_request_duration_seconds")
    print("   â€¢ nethub_errors_total")
    print("   â€¢ nethub_active_connections")
    print("   â€¢ nethub_messages_sent_total")
    print("   â€¢ nethub_messages_received_total")
    print("   â€¢ nethub_bytes_transferred")
    print("   â€¢ nethub_auth_attempts_total")
    print("   â€¢ nethub_ia_response_seconds")
    print("   â€¢ nethub_system_cpu_percent")
    print("   â€¢ nethub_system_memory_bytes")
    print("   â€¢ nethub_database_operations_total")
    print()
    print("âœ… Accede a /metrics en tu API para ver las mÃ©tricas en formato JSON")
    print()
    
    # Prueba
    print("ğŸ§ª Prueba del sistema:")
    REQUEST_COUNT.inc(method="GET", endpoint="test", status="200")
    ACTIVE_CONNECTIONS.set(5, connection_type="tcp")
    
    print("\nMÃ©tricas generadas:")
    print(obtener_metricas())


```
**nethub.py**
```python
#!/usr/bin/env python3
"""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                      NetHub  v2.0                           â•‘
â•‘        Sistema unificado de comunicaciones en red           â•‘
â•‘                                                             â•‘
â•‘  ProgramaciÃ³n de Servicios y Procesos â€” DAM-2               â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Punto de entrada Ãºnico que agrupa todos los mÃ³dulos del proyecto:
  Â· Correo SMTP / IMAP
  Â· Sockets TCP  (cliente / servidor)
  Â· WebSockets   (cliente / servidor)
  Â· IA remota jocarsa
  Â· TAME â€” IA personalizada
  Â· Ollama API  (3 mÃ©todos)
  Â· API REST con FastAPI (autenticaciÃ³n JWT)
  Â· Dashboard web de monitoreo en tiempo real
  Â· Servidor TCP con cifrado TLS/SSL
  Â· Base de datos SQLite3 nativa
  Â· MÃ©tricas nativas (vanilla) para monitoreo

Uso:
    python nethub.py
"""

import sys
import os
import subprocess

# â”€â”€ Ruta base del proyecto â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
BASE = os.path.dirname(os.path.abspath(__file__))


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#  BANNER
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

BANNER = r"""
  â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—    â–ˆâ–ˆâ•—  â–ˆâ–ˆâ•—â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—
  â–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â•â•â•šâ•â•â–ˆâ–ˆâ•”â•â•â•    â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—
  â–ˆâ–ˆâ•”â–ˆâ–ˆâ•— â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—     â–ˆâ–ˆâ•‘       â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•
  â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•     â–ˆâ–ˆâ•‘       â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—
  â–ˆâ–ˆâ•‘ â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•‘       â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•
  â•šâ•â•  â•šâ•â•â•â•â•šâ•â•â•â•â•â•â•   â•šâ•â•       â•šâ•â•  â•šâ•â• â•šâ•â•â•â•â•â• â•šâ•â•â•â•â•â•
      Sistema unificado de comunicaciones en red v2.0
       ProgramaciÃ³n de Servicios y Procesos Â· DAM-2
               ğŸ”’ API REST Â· ğŸ“Š Dashboard Â· ğŸ” TLS
"""

SEPARADOR = "â”€" * 62


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#  IMPORTACIÃ“N DINÃMICA DE MÃ“DULOS
#  Se hace dentro de cada funciÃ³n para no requerir todas las
#  dependencias instaladas si solo se usa un mÃ³dulo concreto.
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def _importar(nombre_fichero: str):
    """Importa dinÃ¡micamente un mÃ³dulo del proyecto por nombre de fichero."""
    import importlib.util
    ruta = os.path.join(BASE, nombre_fichero)
    spec = importlib.util.spec_from_file_location(nombre_fichero, ruta)
    modulo = importlib.util.module_from_spec(spec)
    spec.loader.exec_module(modulo)
    return modulo


def _abrir_nueva_terminal(script: str, titulo: str) -> None:
    """
    Abre el script en una nueva ventana de terminal (Windows).
    Usado para los servidores que bloquean el proceso.
    """
    ruta_script = os.path.join(BASE, script)
    print(f"\n[NetHub] Abriendo '{titulo}' en una nueva ventana...")
    subprocess.Popen(
        ["cmd", "/c", "start", titulo, "python", ruta_script],
        shell=True,
    )


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#  ACCIONES DEL MENÃš
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def accion_smtp():
    print(f"\n{SEPARADOR}")
    print("  MÃ“DULO 1 â€” EnvÃ­o de correo SMTP")
    print(SEPARADOR)
    mod = _importar("001-smtp_envio_correo.py")
    mod.main()


def accion_imap():
    print(f"\n{SEPARADOR}")
    print("  MÃ“DULO 2 â€” Lectura de correo IMAP")
    print(SEPARADOR)
    mod = _importar("002-imap_leer_correo.py")
    mod.main()


def accion_socket_servidor():
    _abrir_nueva_terminal("003a-socket_servidor.py", "NetHub | Servidor TCP")
    print("  Servidor TCP lanzado en una ventana aparte (puerto 9500).")
    print("  CiÃ©rrala con Ctrl+C cuando termines.")


def accion_socket_cliente():
    print(f"\n{SEPARADOR}")
    print("  MÃ“DULO 3B â€” Cliente TCP Socket")
    print(SEPARADOR)
    mod = _importar("003b-socket_cliente.py")
    mod.iniciar_cliente()


def accion_ws_servidor():
    _abrir_nueva_terminal("004a-websocket_servidor.py", "NetHub | Servidor WebSocket")
    print("  Servidor WebSocket lanzado en una ventana aparte (puerto 9501).")
    print("  CiÃ©rrala con Ctrl+C cuando termines.")


def accion_ws_cliente():
    print(f"\n{SEPARADOR}")
    print("  MÃ“DULO 4B â€” Cliente WebSocket")
    print(SEPARADOR)
    mod = _importar("004b-websocket_cliente.py")
    import asyncio
    asyncio.run(mod.main())


def accion_ia_remota():
    print(f"\n{SEPARADOR}")
    print("  MÃ“DULO 5 â€” IA Remota jocarsa")
    print(SEPARADOR)
    mod = _importar("005-ia_remota_jocarsa.py")
    mod.main()


def accion_tame():
    print(f"\n{SEPARADOR}")
    print("  MÃ“DULO 6 â€” TAME (IA personalizada)")
    print(SEPARADOR)
    mod = _importar("006-tame_ia_personalizada.py")
    mod.main()


def accion_ollama():
    print(f"\n{SEPARADOR}")
    print("  MÃ“DULO 7 â€” ConexiÃ³n a Ollama (3 mÃ©todos)")
    print(SEPARADOR)
    mod = _importar("007-ia_ollama_python.py")
    mod.main()


def accion_api_rest():
    _abrir_nueva_terminal("008-api_rest_flask.py", "NetHub | API REST")
    print("  API REST FastAPI lanzada en una ventana aparte (puerto 8000).")
    print("  Accede a http://127.0.0.1:8000/api/docs para la documentaciÃ³n.")
    print("  Dashboard: http://127.0.0.1:8000/dashboard.html")


def accion_servidor_tls():
    _abrir_nueva_terminal("009a-socket_tls_servidor.py", "NetHub | Servidor TLS")
    print("  Servidor TCP con TLS lanzado en una ventana aparte (puerto 9502).")
    print("  CiÃ©rrala con Ctrl+C cuando termines.")


def accion_cliente_tls():
    print(f"\n{SEPARADOR}")
    print("  MÃ“DULO 9B â€” Cliente TCP con TLS/SSL")
    print(SEPARADOR)
    mod = _importar("009b-socket_tls_cliente.py")
    mod.iniciar_cliente_tls()


def accion_inicializar_bd():
    print(f"\n{SEPARADOR}")
    print("  INICIALIZACIÃ“N DE BASE DE DATOS")
    print(SEPARADOR)
    mod = _importar("database_models.py")
    mod.inicializar_base_datos()


def accion_abrir_dashboard():
    print(f"\n{SEPARADOR}")
    print("  ABRIENDO DASHBOARD WEB")
    print(SEPARADOR)
    print("\n  Primero debes iniciar la API REST (opciÃ³n 8)")
    print("  Luego accede a: http://127.0.0.1:8000/dashboard.html")
    print("\n  Â¿Deseas iniciar la API REST ahora? (s/n)")
    
    respuesta = input("  > ").strip().lower()
    if respuesta == 's':
        accion_api_rest()
        print("\n  Espera unos segundos y accede a:")
        print("  http://127.0.0.1:8000/dashboard.html")
        
        import webbrowser
        import time
        time.sleep(2)
        webbrowser.open("http://127.0.0.1:8000/dashboard.html")


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#  MENÃš PRINCIPAL
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

OPCIONES = [
    # (tecla, etiqueta_menÃº, funciÃ³n)
    ("1",  "Enviar correo         [SMTP + TLS]",            accion_smtp),
    ("2",  "Leer correo           [IMAP SSL]",              accion_imap),
    ("â”€",  None, None),
    ("3s", "Lanzar servidor TCP   [nueva ventana]",         accion_socket_servidor),
    ("3c", "Conectar cliente TCP  [interactivo]",           accion_socket_cliente),
    ("â”€",  None, None),
    ("4s", "Lanzar servidor WS    [nueva ventana]",         accion_ws_servidor),
    ("4c", "Conectar cliente WS   [interactivo]",           accion_ws_cliente),
    ("â”€",  None, None),
    ("5",  "IA remota jocarsa     [API REST ngrok]",        accion_ia_remota),
    ("6",  "TAME â€” IA docente     [Ollama local]",          accion_tame),
    ("7",  "Ollama API  3 mÃ©todos [demostraciÃ³n]",          accion_ollama),
    ("â”€",  None, None),
    ("8",  "API REST + Dashboard  [FastAPI puerto 8000]",   accion_api_rest),
    ("9s", "Servidor TCP con TLS  [cifrado SSL]",           accion_servidor_tls),
    ("9c", "Cliente TCP con TLS   [conexiÃ³n segura]",       accion_cliente_tls),
    ("â”€",  None, None),
    ("db", "Inicializar BD        [SQLite]",                accion_inicializar_bd),
    ("web","Abrir Dashboard       [navegador]",             accion_abrir_dashboard),
]


def mostrar_menu() -> None:
    os.system("cls" if os.name == "nt" else "clear")
    print(BANNER)
    print(SEPARADOR)
    for clave, etiqueta, _ in OPCIONES:
        if clave == "â”€":
            print()
        else:
            print(f"  [{clave:>2}]  {etiqueta}")
    print()
    print(f"  [ 0]  Salir")
    print(SEPARADOR)


def ejecutar_opcion(clave: str) -> bool:
    """Ejecuta la acciÃ³n correspondiente. Retorna False si hay que salir."""
    if clave == "0":
        return False

    for c, _, fn in OPCIONES:
        if c == clave and fn is not None:
            try:
                fn()
            except KeyboardInterrupt:
                print("\n[NetHub] â¬…  Volviendo al menÃº...")
            except ImportError as e:
                print(f"\n[NetHub] âš ï¸  Dependencia no instalada: {e}")
                print("           Ejecuta: pip install python-dotenv requests websockets ollama")
            except Exception as e:  # noqa: BLE001
                print(f"\n[NetHub] âŒ Error inesperado: {e}")
            input("\n  Pulsa ENTER para volver al menÃº...")
            return True

    print(f"\n[NetHub] âš ï¸  OpciÃ³n '{clave}' no reconocida.")
    input("  Pulsa ENTER para continuar...")
    return True


def main() -> None:
    while True:
        mostrar_menu()
        try:
            opcion = input("  Elige una opciÃ³n > ").strip().lower()
        except (EOFError, KeyboardInterrupt):
            opcion = "0"

        if not ejecutar_opcion(opcion):
            print("\n  ğŸ‘‹ Â¡Hasta pronto! â€” NetHub\n")
            sys.exit(0)


if __name__ == "__main__":
    main()

```